<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Kubernetes," />










<meta name="description" content="[TOC]  本文是把《Kubernetes In Action》读薄的摘抄或转述，仅供参考。系统学习请阅读原书。k8s的命令繁多，熟练使用它们提高工作效率和理解k8s设计思想同等重要，每章最后总结了该章涉及的命令。    2019~2020年期间，在工作上使用过Kubernetes(k8s)+Istio治理微服务。我们的业务是做一个Iass+Paas平台，我们把计算、网络、存储、安全、数据库、负">
<meta property="og:type" content="article">
<meta property="og:title" content="《Kubernetes In Action》阅读笔记(一)">
<meta property="og:url" content="https://pearlzju.github.io/2021/06/13/%E3%80%8AKubernetes%20In%20Action%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%B8%80)/index.html">
<meta property="og:site_name" content="Pearl 的个人小站">
<meta property="og:description" content="[TOC]  本文是把《Kubernetes In Action》读薄的摘抄或转述，仅供参考。系统学习请阅读原书。k8s的命令繁多，熟练使用它们提高工作效率和理解k8s设计思想同等重要，每章最后总结了该章涉及的命令。    2019~2020年期间，在工作上使用过Kubernetes(k8s)+Istio治理微服务。我们的业务是做一个Iass+Paas平台，我们把计算、网络、存储、安全、数据库、负">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/0.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/1.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/2.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/3.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/4.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/5.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/6.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/7.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/8.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/9.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/10.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/11.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/12.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/13.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/14.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/15.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/16.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/17.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/18.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/19.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/20.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/21.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/22.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/23.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/24.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/25.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/26.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/27.png">
<meta property="og:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/28.png">
<meta property="article:published_time" content="2021-06-13T02:17:28.829Z">
<meta property="article:modified_time" content="2021-06-18T09:07:30.352Z">
<meta property="article:author" content="Pearl">
<meta property="article:tag" content="Kubernetes">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pearlzju.github.io/images/Kubernetes%20In%20Action%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/0.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://pearlzju.github.io/2021/06/13/《Kubernetes In Action》阅读笔记(一)/"/>





  <title>《Kubernetes In Action》阅读笔记(一) | Pearl 的个人小站</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e99d362e55bda406e16937db2b48aebc";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Pearl 的个人小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">终身学习者</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pearlzju.github.io/2021/06/13/%E3%80%8AKubernetes%20In%20Action%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%B8%80)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Pearl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/face.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pearl 的个人小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">《Kubernetes In Action》阅读笔记(一)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-13T10:17:28+08:00">
                2021-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/06/13/%E3%80%8AKubernetes%20In%20Action%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%B8%80)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/06/13/%E3%80%8AKubernetes%20In%20Action%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%B8%80)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2021/06/13/%E3%80%8AKubernetes%20In%20Action%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%B8%80)/" class="leancloud_visitors" data-flag-title="《Kubernetes In Action》阅读笔记(一)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<blockquote>
<p>本文是把《Kubernetes In Action》读薄的摘抄或转述，仅供参考。系统学习请阅读原书。<br>k8s的命令繁多，熟练使用它们提高工作效率和理解k8s设计思想同等重要，每章最后总结了该章涉及的命令。</p>
</blockquote>
<img width="300" src="/images/Kubernetes In Action阅读笔记/0.png">

<p>2019~2020年期间，在工作上使用过Kubernetes(k8s)+Istio治理微服务。我们的业务是做一个Iass+Paas平台，我们把计算、网络、存储、安全、数据库、负载均衡和监控等模块拆分成微服务，每个服务在一组相同的pod运行，每个pod中运行两个容器，业务容器和sidecar。Istio Ingress作为k8s的Ingress Controller，用于对外暴露服务，并且管理南北向流量。Istio的sidecar注入pod，用于管理集群内服务之间的东西向流量。</p>
<p>当时我只是在项目中应用了istio+k8s，没有系统学习过k8s，包括它的设计思想。最近因为工作再次接触k8s，于是挑选了《Kubernetes In Action》进行系统学习和温故而知新，这确实是一本不多见的涵盖广阔提纲挈领的好书。</p>
<p>微服务架构，它从管理上获取对服务的抽象，方便服务的管理和规划服务的边界。但它因为引入了很多新的机制，比如服务注册中心等，其实对硬件而言是一种牺牲。但舍弃一定的性能，换来的是服务的治理、团队协作开发的方便，这就是微服务架构的价值。</p>
<p>程序的本质从不同角度观察，会有不同的见解，就像光的波粒二象性。我的观点是不浪费硬件是对提升性能最大的帮助。会有听到微服务解决了高并发问题的说法，但微服务和高并发其实没有必然关系。而是因为通常微服务会使用分布式方式部署，硬件资源包括CPU、网络、磁盘等成倍增加，所以分布式对高并发问题有积极作用。</p>
<p>Istio，它其实不局限于微服务治理范畴，任何服务，只要服务间有访问，需要对服务间的流量进行管理、服务间认证等，都可以使用Istio来管理。</p>
<p>k8s不是一个专为Docker设计的容器编排系统。k8s的核心也不止是编排容器，只不过容器恰好是在不同集群节点上运行应用的最佳方式。k8s可以被看作集群的一个操作系统，提供服务发现、扩容、负载均衡、自恢复、leader选举等功能。</p>
<h1 id="1-Kubernetes-介绍-1"><a href="#1-Kubernetes-介绍-1" class="headerlink" title="1 Kubernetes 介绍 1"></a>1 Kubernetes 介绍 1</h1><p>微服务架构是替代以单个进程或几个进程运行在服务器上为部署方式的单体应用的一种方式，它将单体应用分解成若干个可独立运行组件。微服务的解耦性，确保它们可以被独立开发、部署、升级、伸缩。<br>如何部署、管理这些微服务，并充分利用宿主机的硬件资源，诞生了k8s。k8s可以理解为是一个数据中心操作系统(DCOS)，他将人员分为开发人员和系统管理员，系统管理员负责处理和硬件、集群相关的事务，开发人员只需要提交自己的应用和描述。k8s会「自动」按照开发人员的描述，把应用启动起来，并暴露定义的端口。</p>
<blockquote>
<p>在computer science领域，有一句话”All problems in computer science can be solved by another level of indirection”。k8s抽象了数据中心的硬件基础设置，对外暴露资源池API，开发人员不用关心底层的硬件设施。这种抽象和操作系统也有相似之处。</p>
</blockquote>
<h2 id="1-1-Kubernetes-系统的需求-2"><a href="#1-1-Kubernetes-系统的需求-2" class="headerlink" title="1.1 Kubernetes 系统的需求 2"></a>1.1 Kubernetes 系统的需求 2</h2><h3 id="1-1-1-从单体应用到微服务-2"><a href="#1-1-1-从单体应用到微服务-2" class="headerlink" title="1.1.1 从单体应用到微服务 2"></a>1.1.1 从单体应用到微服务 2</h3><p>对于单体应用，为了提升系统负载能力，有两种扩展方式。<br>垂直扩展：增加CPU、内存或其它系统资源。应用程序无需变化，但成本越来越高，无法无限扩展。<br>水平扩展：经常需要应用程序进行改动才可执行，可能会被某个模块无法水平扩展限制。</p>
<p>单体应用可被拆分成多个可独立部署、以独立进程运行的微服务，微服务之间以约定的API通信。</p>
<p>对于微服务架构，可以只扩容某些服务，因为扩容粒度细化，可以根据具体情况分配扩容资源。</p>
<blockquote>
<p>如果有历史项目是单体应用，不得不水平扩容，而水平扩容受到某些模块的限制。可以把应用拆分成多个微服务，对能扩容的组件水平扩展，对不能扩容的组件垂直扩展。</p>
</blockquote>
<p>看似一切很美好，微服务带来的弊端不容忽视。<br>当服务数量激增，如何处理服务间错综复杂的依赖关系，如何把正确的配置应用到每个服务，如何调试代码和定位异常调用，如何解决不同服务对于环境需求的差异，都是需要面对的。</p>
<h3 id="1-1-2-为应用程序提供一个一致的环境-5"><a href="#1-1-2-为应用程序提供一个一致的环境-5" class="headerlink" title="1.1.2 为应用程序提供一个一致的环境 5"></a>1.1.2 为应用程序提供一个一致的环境 5</h3><p>目标是让服务在开发和生产阶段可以运行在完全一样的环境下，有完全一样的操作系统、库、系统配置、网络环境等。各个服务之间独立互不影响。</p>
<h3 id="1-1-3-迈向持续交付-：DevOps-和无运维-6"><a href="#1-1-3-迈向持续交付-：DevOps-和无运维-6" class="headerlink" title="1.1.3 迈向持续交付 ：DevOps 和无运维 6"></a>1.1.3 迈向持续交付 ：DevOps 和无运维 6</h3><p>让应用开发者和系统管理员解耦，开发者可以自己参与配置和部署程序，但又无需关注硬件基础设施。而实际上系统管理员在幕后保证底层基础设施正常运转，但他们也无需关注运行的程序本身。<br>这正是k8s实现的功能。它对硬件资源进行抽象，对外暴露成一个平台，用于部署和运行应用程序。</p>
<h2 id="1-2-介绍容器技术-7"><a href="#1-2-介绍容器技术-7" class="headerlink" title="1.2 介绍容器技术 7"></a>1.2 介绍容器技术 7</h2><p>k8s使用Linux容器技术来实现对应用的隔离。</p>
<h3 id="1-2-1-什么是容器-7"><a href="#1-2-1-什么是容器-7" class="headerlink" title="1.2.1 什么是容器 7"></a>1.2.1 什么是容器 7</h3><p>虚拟机可以隔离不同的微服务环境是显然的，Linux容器技术也可以。容器和虚拟机相比开销小很多，容器里运行的进程实际上运行在宿主机上，但是和其它进程隔离，开销仅是容器消耗的资源。</p>
<p>虚拟机和容器中的应用进程对CPU的使用方式不同。每个虚拟机对应的Linux内核不一样，而不同容器对应的Linux内核一样（存在安全隐患）。如图所示。</p>
<img width="400" src="/images/Kubernetes In Action阅读笔记/1.png">

<p>如果多个进程运行在同一个操作系统上，是怎么利用容器是隔离它们的？有两个机制可用。</p>
<ol>
<li>Linux命名空间。可以在某个命名空间运行一个进程，进程只能看到这个命名空间下的资源。当然，会存在多种类型的命名空间，所以一个进程不单单只属于某一个命名空间，而属于每个类型的一个命名空间。</li>
</ol>
<p>存在以下类型的命名空间：</p>
<ul>
<li>Mount（mnt）</li>
<li>Process ID（pid）</li>
<li>Network（net）</li>
<li>Inter-process communicaion（ipd）</li>
<li>UTS</li>
<li>User ID（user）</li>
</ul>
<ol start="2">
<li>内核的cgroups。限制进程能使用的资源量（CPU、内存、网络带宽等）不能超过被分配的量。</li>
</ol>
<h3 id="1-2-2-Docker-容器平台介绍-11"><a href="#1-2-2-Docker-容器平台介绍-11" class="headerlink" title="1.2.2 Docker 容器平台介绍 11"></a>1.2.2 Docker 容器平台介绍 11</h3><p>Docker是第一个使容器成为主流的容器平台。Docker本身不提供进程隔离，而是由Linux命名空间和cgroups之类的内核特性完成。</p>
<p>镜像层是只读的。容器运行时，一个新的可写层在镜像层之上被创建。 容器中进程写入位于底层的一个文件时，此文件的一个拷贝在顶层被创建，进程写的是此拷贝。</p>
<p>Docker可以借助于镜像在不同操作系统之间移植，但是内核由运行容器的宿主机决定。如果一个容器化的应用需要一个特定的内核版本，那它可能不能在每台机器上都工作。 如果一台机器上运行了一个不匹配的 Linux 内核版本，或者没有相同内核模块可用，那么此应用就不能在其上运行。所以容器镜像存在移植性的限制，在不同CPU架构上构建的镜像不能通用。例如在x86平台构建的镜像，不能在arm平台使用。</p>
<h3 id="1-2-3-rkt——一个-Docker-的替代方案-14"><a href="#1-2-3-rkt——一个-Docker-的替代方案-14" class="headerlink" title="1.2.3 rkt——一个 Docker 的替代方案 14"></a>1.2.3 rkt——一个 Docker 的替代方案 14</h3><p>开放容器计划OCI是围绕容器格式和运行时创建的开放工业标准。kubelet以CRI标准接口与OCI进行通信。rkt是另一个Linux容器引擎。</p>
<p>本书集中使用Docker作为k8s的容器，它是k8s最初唯一支持的容器类型，但k8s目前也支持rkt等其它容器类型。</p>
<h2 id="1-3-Kubernetes-介绍-15"><a href="#1-3-Kubernetes-介绍-15" class="headerlink" title="1.3 Kubernetes 介绍 15"></a>1.3 Kubernetes 介绍 15</h2><h3 id="1-3-1-初衷-15"><a href="#1-3-1-初衷-15" class="headerlink" title="1.3.1 初衷 15"></a>1.3.1 初衷 15</h3><p>在海量服务器规模下，有效处理部署管理，并提高基础设施利用率。</p>
<h3 id="1-3-2-深入浅出地了解-Kubernetes-15"><a href="#1-3-2-深入浅出地了解-Kubernetes-15" class="headerlink" title="1.3.2 深入浅出地了解 Kubernetes 15"></a>1.3.2 深入浅出地了解 Kubernetes 15</h3><p>k8s整个系统由一个主节点和若干个工作节点组成。开发者把一个应用列表提交到主节点，k8s会将它们部署到集群的工作节点。组件被部署在哪个节点对于开发者和系统管理员来说都不用关心 。开发者能指定一些应用必须一起运行，k8s将会在一个工作节点上部署它们。其他的将被分散部署到集群中，但是不管部署在哪儿，它们都能以相同的方式互相通信。</p>
<img width="500" src="/images/Kubernetes In Action阅读笔记/2.png">

<h3 id="1-3-3-Kubernetes-集群架构-17"><a href="#1-3-3-Kubernetes-集群架构-17" class="headerlink" title="1.3.3 Kubernetes 集群架构 17"></a>1.3.3 Kubernetes 集群架构 17</h3><p>一个k8s集群由很多节点组成，分为两种类型：</p>
<ol>
<li>主节点：它承载着k8s控制和管理整个集群系统的控制面板。控制面板的组件持有井控制集群状态，但是它们不运行应用，运行应用是由工作节点完成的。</li>
</ol>
<ul>
<li>API服务器：应用和其它控制面板组件都要和它通信。</li>
<li>Scheculer：调度应用(为应用的每个可部署组件分配一个工作节点)。</li>
<li>Controller Manager：执行集群级别的功能，如复制组件、持续跟踪工作节点、处理节点失败等。</li>
<li>etcd：一个可靠的分布式数据存储，它能持久化存储集群配置。</li>
</ul>
<ol start="2">
<li>工作节点：它们运行用户实际部署的应用。</li>
</ol>
<ul>
<li>Docker、rkt或其它容器类型。</li>
<li>Kubelet：与API服务器通信，并管理它所在节点的容器。</li>
<li>kube-proxy：负责组件之间的负载均衡网络流量。</li>
</ul>
<img width="500" src="/images/Kubernetes In Action阅读笔记/3.png">

<h3 id="1-3-4-在-Kubernetes-中运行应用-18"><a href="#1-3-4-在-Kubernetes-中运行应用-18" class="headerlink" title="1.3.4 在 Kubernetes 中运行应用 18"></a>1.3.4 在 Kubernetes 中运行应用 18</h3><p>在向k8提交描述符之后，它将把每个pod的指定副本数量调度到可用的工作节点上。 节点上的 Kubelets将告知Docker从镜像仓库中拉取 容器镜像井运行容器。 </p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/4.png">

<p>一旦应用程序运行起来，k8s就会不断地确认应用程序的部署状态始终与你提供的描述相匹配。</p>
<p>k8s采用声明式的控制流，所有的资源声明都保存在etcd，所有的组件都通过API Server来声明或监听资源。只要资源被声明，那么监听资源的控制器就会开始工作，确保让各个资源实例达到声明的状态。</p>
<h3 id="1-3-5-使用-Kubernetes-的好处-20"><a href="#1-3-5-使用-Kubernetes-的好处-20" class="headerlink" title="1.3.5 使用 Kubernetes 的好处 20"></a>1.3.5 使用 Kubernetes 的好处 20</h3><ul>
<li>简化应用程序部署</li>
<li>更好地利用硬件</li>
<li>健康检查和自修复</li>
<li>自动扩容</li>
<li>敏捷交付</li>
</ul>
<h1 id="2-开始使用-Kubernetes-和-Docker-23"><a href="#2-开始使用-Kubernetes-和-Docker-23" class="headerlink" title="2 开始使用 Kubernetes 和 Docker 23"></a>2 开始使用 Kubernetes 和 Docker 23</h1><h2 id="2-1-创建、运行及共享容器镜像-23"><a href="#2-1-创建、运行及共享容器镜像-23" class="headerlink" title="2.1 创建、运行及共享容器镜像 23"></a>2.1 创建、运行及共享容器镜像 23</h2><p>容器中的进程是运行在主机操作系统上的，但是该进程的ID在主机上和容器中不同。容器使用独立的PID Linux命令空间并且有着独立的系列号，完全独立于进程树。</p>
<p>正如拥有独立的进程树一 样，每个容器也拥有独立的文件系统。在容器内列出 根目录的内容，只会展示容器内的文件，包括镜像内的所有文件，再加上容器运行时创建的任何文件(类似日志文件)。</p>
<p>使用是比较简单的，本文不赘述了。</p>
<h2 id="2-2-配置-Kubernetes-集群-34"><a href="#2-2-配置-Kubernetes-集群-34" class="headerlink" title="2.2 配置 Kubernetes 集群 34"></a>2.2 配置 Kubernetes 集群 34</h2><p>主要讲如何创建k8s集群，讲了两个方法：用 Minikube 运行一个本地单节点 Kubernetes 集群；用 Google Kubernetes Engine 托管 Kubernetes 集群。以及为kubectl 配置别名和命令行补齐，方便命令输入。</p>
<p>使用是比较简单的，本文不赘述了。</p>
<h2 id="2-3-在-Kubernetes-上运行第一个应用-40"><a href="#2-3-在-Kubernetes-上运行第一个应用-40" class="headerlink" title="2.3 在 Kubernetes 上运行第一个应用 40"></a>2.3 在 Kubernetes 上运行第一个应用 40</h2><h3 id="2-3-1-部署-Node-js-应用-40"><a href="#2-3-1-部署-Node-js-应用-40" class="headerlink" title="2.3.1 部署 Node.js 应用 40"></a>2.3.1 部署 Node.js 应用 40</h3><p>一个pod是一组紧密相关的容器，它们总是一起运行在同一个工作节点上，以及同一个Linux命名空间中。每个pod就像一个独立的逻辑机器，拥有自己的IP、主机名、进程等，运行一个独立的应用程序。应用程序可以是单个进程，运行在单个容器中，也可以是一个主应用进程或者其他支持进程，每个进程都在自己的容器中运行。一个pod的所有容器都运行在同一个逻辑机器上，而其它pod中的容器，即使运行在同 一个工作节点上，也会出现在不同的节点上 。</p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/5.png">

<p>当运行kubectl命令时，它通过向API服务器发送一个REST HTTP请求，在集群中创建一个新的ReplicationController对象。然后，ReplicationController创建了一个新的pod，调度器将其调度到 一个工作节点上。Kubelet看到pod被调度到节点上，就告知Docker从镜像中心中拉取指定的镜像，因为本地没有该镜像。下载镜像后，Docker创建并运行容器。</p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/6.png">

<h3 id="2-3-2-访问-Web-应用-43"><a href="#2-3-2-访问-Web-应用-43" class="headerlink" title="2.3.2 访问 Web 应用 43"></a>2.3.2 访问 Web 应用 43</h3><p>每个pod有自己的IP地址，但是这个地址是集群内部的，不能从集群外部访问。要让pod能够从外部访问，需要通过服务对象公开它，要创建一个LoadBalancer类型的服务。它将创建一个外部的负载均衡，外部可以通过负载均衡的公共IP访问pod。</p>
<h3 id="2-3-3-系统的逻辑部分-45"><a href="#2-3-3-系统的逻辑部分-45" class="headerlink" title="2.3.3 系统的逻辑部分 45"></a>2.3.3 系统的逻辑部分 45</h3><p>k8s的基本构件是pod，但是没有直接创建和使用pod。通过运行<code>kubectl run</code>命令，创建了一个ReplicationController，它用于创建pod实例 。为了使该pod能够从集群外部访问，需要让 k8s将 该ReplicationController管理的所有pod由一个服务对外暴露。服务表示一组或多组提供相同服务的pod的静态地址。到达服务IP和端口的请求将被转发到属于该服务的一个容器的IP和端口。</p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/7.png">

<h3 id="2-3-4-水平伸缩应用-46"><a href="#2-3-4-水平伸缩应用-46" class="headerlink" title="2.3.4 水平伸缩应用 46"></a>2.3.4 水平伸缩应用 46</h3><p>为了增加pod的副本数，需要改变ReplicationController期望的副本数。告诉k8s需要确保pod始终有三个实例在运行。成功后，请求会随机地切到不同的pod。</p>
<blockquote>
<p>应用本身需要支持水平伸缩。</p>
</blockquote>
<p>没有告诉k8s需要采取什么行动，也没有告诉k8s增加两个pod，只设置新的期望的实例数量并让 k8s决定需要采取哪些操作来实现期望的状态。这是k8s最基本的原则之一。不是告诉 k8s 应该执行什么操作，而是声明性地改变系统的期望状态，并让k8s检查当前的状态是否与期望的状态一致。在整个 k8s 世界中都是这样的——声明式设计。</p>
<h3 id="2-3-5-查看应用运行在哪个节点上-49"><a href="#2-3-5-查看应用运行在哪个节点上-49" class="headerlink" title="2.3.5 查看应用运行在哪个节点上 49"></a>2.3.5 查看应用运行在哪个节点上 49</h3><p>不管调度到哪个节点，容器中运行的所有应用都具有相同类型的操作系统。每个pod都有自己的IP，并且可以与任何其他pod通信，不论其他pod是运行在同一 个节点上，还是运行在另一个节点上。每个pod都被分配到所需的计算资源，因此这些资源是由一个节点提供还是由另一个节点提供，并没有任何区别。</p>
<h3 id="2-3-6-介绍-Kubernetes-dashboard-50"><a href="#2-3-6-介绍-Kubernetes-dashboard-50" class="headerlink" title="2.3.6 介绍 Kubernetes dashboard 50"></a>2.3.6 介绍 Kubernetes dashboard 50</h3><p>k8s的图形化用户界面。列出部署在集群中的所有pod、ReplicationController、服务和其他部署在集群中的对象， 以及创建、修改和删除它们。</p>
<h2 id="2-4-本章的k8s命令"><a href="#2-4-本章的k8s命令" class="headerlink" title="2.4 本章的k8s命令"></a>2.4 本章的k8s命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">########## 集群 ##########  </span><br><span class="line"></span><br><span class="line"># 展示集群信息</span><br><span class="line">$ kubectl cluster-info</span><br><span class="line"></span><br><span class="line"># 获取dashboard的URL</span><br><span class="line">$ kubectl cluster-info | grep dashboard</span><br><span class="line"></span><br><span class="line">########## node ##########  </span><br><span class="line"></span><br><span class="line"># 列出集群节点</span><br><span class="line">$ kubectl get nodes</span><br><span class="line"></span><br><span class="line">########## pod ##########  </span><br><span class="line"></span><br><span class="line"># 列出所有pod</span><br><span class="line">$ kubectl get pods</span><br><span class="line">可以加上 -o wide 选项请求其它列</span><br><span class="line"></span><br><span class="line"># 描述一个pod</span><br><span class="line">$ kubectl describe pod kubia-hczji</span><br><span class="line"></span><br><span class="line">########## service ##########  </span><br><span class="line"></span><br><span class="line"># 列出所有服务</span><br><span class="line">$ kubectl get services(缩写svc)</span><br><span class="line"></span><br><span class="line">########## ReplicationController ##########  </span><br><span class="line"></span><br><span class="line"># 创建一个ReplicationController</span><br><span class="line">$ kubectl run kubia --image&#x3D;luksa&#x2F;kubia --port&#x3D;8080 --generator&#x3D;run&#x2F;v1</span><br><span class="line"></span><br><span class="line"># 改变ReplicationController期望的副本数</span><br><span class="line">$ kubectl scale re kubia --replicas&#x3D;3</span><br><span class="line"></span><br><span class="line"># 列出ReplicationController</span><br><span class="line">$ kubectl get replicationcontroller(缩写rc)</span><br><span class="line"></span><br><span class="line">########## LoadBalancer ##########  </span><br><span class="line"></span><br><span class="line"># 创建LoadBalancer服务对象</span><br><span class="line">$ kubectl expose rc kubia --type&#x3D;LoadBalancer --name kubia-http</span><br></pre></td></tr></table></figure>

<h1 id="3-pod-：运行于-Kubernetes-中的容器-53"><a href="#3-pod-：运行于-Kubernetes-中的容器-53" class="headerlink" title="3 pod ：运行于 Kubernetes 中的容器 53"></a>3 pod ：运行于 Kubernetes 中的容器 53</h1><p>pod是k8s中最重要的核心概念，而其他对象仅仅是在管理、 暴露pod或被pod使用。</p>
<h2 id="3-1-介绍-pod-53"><a href="#3-1-介绍-pod-53" class="headerlink" title="3.1 介绍 pod 53"></a>3.1 介绍 pod 53</h2><p>当一个 pod包含多个容器时，这些容器总是运行于同一个工作节点上。一个pod绝不会跨越多个工作节点。</p>
<h3 id="3-1-1-为何需要-pod-54"><a href="#3-1-1-为何需要-pod-54" class="headerlink" title="3.1.1 为何需要 pod 54"></a>3.1.1 为何需要 pod 54</h3><p>容器被设计为每个容器只运行一个进程(除非进程本身产生子进程)。如果在单个容器中运行多个不相关的进程，那么保持所有进程运行、管理它们的日志等将会是我们的责任。例如，我们需要包含一种在进程崩溃时能够自动重启的机制。同时这些进程都将记录到相同的标准输出中， 而此时我们将很难确定每个进程分别记录了什么。<br>我们需要让每个进程运行于自己的容器中，而这就是Docker和k8s期望使用的方式。<br>pod是k8s调度的最小单位，一个 pod可以包含一个或多个容器。</p>
<h3 id="3-1-2-了解-pod-55"><a href="#3-1-2-了解-pod-55" class="headerlink" title="3.1.2 了解 pod 55"></a>3.1.2 了解 pod 55</h3><p>由于不能将多个进程聚集在一个单独的容器中，我们需要另一种更高级的结构来将容器绑定在一 起，并将它们作为一个单元进行管理，这就是pod背后的根本原理。</p>
<p>k8s通过配置Docker来让一个pod内的所有容器共享相同的Linux命名空间，而不是每个容器都有自己的一组命名空间。</p>
<p>由于一个pod中的所有容器都在相同的network和UTS命名空间下运行，所以它们都共享相同的主机名和网络接口。 同一个pod中的容器共享相同的IP地址和端口空间。同样地，这些容器也都在相同的IPC命名空间下运行，因此能够通过IPC进行通信。在最新的k8s和Docker版本中，它们也能够共享相同的PID命名空间（但是该特征默认是未激活的）。</p>
<p>k8s集群的pod之间没有NAT网关，两个pod彼此之间发送网络数据包时，它们都会将对方的实际IP地址看作数据包中的源IP。</p>
<h3 id="3-1-3-通过-pod-合理管理容器-56"><a href="#3-1-3-通过-pod-合理管理容器-56" class="headerlink" title="3.1.3 通过 pod 合理管理容器 56"></a>3.1.3 通过 pod 合理管理容器 56</h3><p>当决定是将两个容器放入一个pod还是 两个单独的pod时，我们需要问自己以下问题:</p>
<ul>
<li>它们需要 一起运行还是可以在不同的主机上运行?</li>
<li>它们代表的是一个整体还是相互独立的组件?</li>
<li>它们必须一起进行扩缩容还是可以分别进行? </li>
</ul>
<p>我们总是应该倾向于在单独的pod中运行容器，除非有特定的原因要求它们是同一pod的一部分。<br>比如常见的是sidecar容器，用于日志轮转器和收集器、数据处理器、通信适配器等。</p>
<blockquote>
<p>在实际业务场景中，在pod中使用多个容器，sidecar是最常见的方式。其它情况，需要三思。</p>
</blockquote>
<img width="600" src="/images/Kubernetes In Action阅读笔记/8.png">

<h2 id="3-2-以-YAML-或-JSON-描述文件创建-pod-58"><a href="#3-2-以-YAML-或-JSON-描述文件创建-pod-58" class="headerlink" title="3.2 以 YAML 或 JSON 描述文件创建 pod 58"></a>3.2 以 YAML 或 JSON 描述文件创建 pod 58</h2><p>pod和其它k8s资源通常是通过向k8s REST API提供JSON或YAML描述文件来创建的。<br>全面的文档在<a href="https://kubernetes.io/docs/reference/kubernetes-api/" target="_blank" rel="noopener">Kubernetes API参考文档</a>。</p>
<h3 id="3-2-1-检查现有-pod-的-YAML-描述文件-59"><a href="#3-2-1-检查现有-pod-的-YAML-描述文件-59" class="headerlink" title="3.2.1 检查现有 pod 的 YAML 描述文件 59"></a>3.2.1 检查现有 pod 的 YAML 描述文件 59</h3><p>pod定义由这几个部分组成：首先是YAML中使用的k8s API版本和YAML描述的资源类型；其次是几乎在所有k8s资源中都可以找到的三大重要部分：</p>
<ul>
<li>metadata：包括名称、命名空间、标签和关于该容器的其他信息。</li>
<li>spec：包含pod内容的实际说明，例如pod的容器、卷和其他数据。</li>
<li>status：包含运行中的pod的当前信息，例如pod所处的条件、 每个容器的描述和状态，以及内部IP和其他基本信息。status只包含只读的运行时数据，在创建新的pod时，不需要提供status部分。</li>
</ul>
<h3 id="3-2-2-为-pod-创建一个简单的-YAML-描述文件-61"><a href="#3-2-2-为-pod-创建一个简单的-YAML-描述文件-61" class="headerlink" title="3.2.2 为 pod 创建一个简单的 YAML 描述文件 61"></a>3.2.2 为 pod 创建一个简单的 YAML 描述文件 61</h3><p>一个基本的pod描述文件非常简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-manual</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: luksa&#x2F;kubia</span><br><span class="line">    name: kubia</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 8080</span><br><span class="line">      protocol: TCP</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-使用-kubectl-create-来创建-pod-63"><a href="#3-2-3-使用-kubectl-create-来创建-pod-63" class="headerlink" title="3.2.3 使用 kubectl create 来创建 pod 63"></a>3.2.3 使用 kubectl create 来创建 pod 63</h3><p><code>kubectl create -f</code>命令用于从YAML或JSON文件创建任何资源。创建后可以请求k8s获得完整的YAML和JSON格式的描述文件。</p>
<h3 id="3-2-4-查看应用程序日志-64"><a href="#3-2-4-查看应用程序日志-64" class="headerlink" title="3.2.4 查看应用程序日志 64"></a>3.2.4 查看应用程序日志 64</h3><p>当日志文件达到一定大小时，容器日志会自动轮替。<code>kubectl logs</code>命令仅显示最后一次轮替后的日志条目。</p>
<p>当一个pod被删除时，它的日志也会被删除。如果希望在pod删除之后仍然可以获取其日志，我们需要设置中心化的、集群范围的日志系统，将所有日志存储到中心存储中。 </p>
<h3 id="3-2-5-向-pod-发送请求-65"><a href="#3-2-5-向-pod-发送请求-65" class="headerlink" title="3.2.5 向 pod 发送请求 65"></a>3.2.5 向 pod 发送请求 65</h3><p>如果要在外部访问pod，除了前面提到的lb service，还可以借助端口转发（常用于开发中测试pod）。端口转发通过<code>kubectl port-forward</code>命令完成。</p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/9.png">

<h2 id="3-3-使用标签组织-pod-66"><a href="#3-3-使用标签组织-pod-66" class="headerlink" title="3.3 使用标签组织 pod 66"></a>3.3 使用标签组织 pod 66</h2><p>通过一次操作对属于某个组的所有pod进行操作，而不必单独为每个pod执行操作。<br>标签可以做到这一点。通过标签来组织pod和所有其他k8s对象。</p>
<h3 id="3-3-1-介绍标签-66"><a href="#3-3-1-介绍标签-66" class="headerlink" title="3.3.1 介绍标签 66"></a>3.3.1 介绍标签 66</h3><p>标签是可以附加到资源的任意键值对。通过标签选择器可以选择具有确切标签的资源。<br>标签和资源是多对多关系。</p>
<p>比如常用的场景有，给每个pod标有两个标签。</p>
<ul>
<li>app：它指定pod属于哪个应用、 组件或微服务。</li>
<li>rel：它显示在pod中运行的应用程序版本是stable、beta还是canary（用于金丝雀发布）。</li>
</ul>
<img width="600" src="/images/Kubernetes In Action阅读笔记/10.png">

<h3 id="3-3-2-创建-pod-时指定标签-67"><a href="#3-3-2-创建-pod-时指定标签-67" class="headerlink" title="3.3.2 创建 pod 时指定标签 67"></a>3.3.2 创建 pod 时指定标签 67</h3><p>包含creation_method=manual，env=prod两个标签。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-manual-v2</span><br><span class="line">  labels:</span><br><span class="line">    creation_method: manual</span><br><span class="line">    env: prod</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3-修改现有-pod-的标签-68"><a href="#3-3-3-修改现有-pod-的标签-68" class="headerlink" title="3.3.3 修改现有 pod 的标签 68"></a>3.3.3 修改现有 pod 的标签 68</h3><p>标签可以在现有pod上进行添加和修改。</p>
<h2 id="3-4-通过标签选择器列出-pod-子集-69"><a href="#3-4-通过标签选择器列出-pod-子集-69" class="headerlink" title="3.4 通过标签选择器列出 pod 子集 69"></a>3.4 通过标签选择器列出 pod 子集 69</h2><p>标签要与标签选择器结合，否则标签没有作用。</p>
<h3 id="3-4-1-使用标签选择器列出-pod-69"><a href="#3-4-1-使用标签选择器列出-pod-69" class="headerlink" title="3.4.1 使用标签选择器列出 pod 69"></a>3.4.1 使用标签选择器列出 pod 69</h3><p>标签选择器根据资源的以下条件来选择资源：</p>
<ul>
<li>包含(或不包含)使用特定键的标签。</li>
<li>包含具有特定键和值的标签。</li>
<li>包含具有特定键的标签，但其值与我们指定的不同。</li>
</ul>
<h3 id="3-4-2-在标签选择器中使用多个条件-71"><a href="#3-4-2-在标签选择器中使用多个条件-71" class="headerlink" title="3.4.2 在标签选择器中使用多个条件 71"></a>3.4.2 在标签选择器中使用多个条件 71</h3><p>在包含多个逗号分隔的清况下，可以在标签选择器中同时使用多个条件。 此时，资源需要全部匹配才算成功匹配了选择器。</p>
<h2 id="3-5-使用标签和选择器来约束-pod-调度-71"><a href="#3-5-使用标签和选择器来约束-pod-调度-71" class="headerlink" title="3.5 使用标签和选择器来约束 pod 调度 71"></a>3.5 使用标签和选择器来约束 pod 调度 71</h2><p>在硬件基础设施不是同质的情况下，比如想将执行GPU密集型运算的pod调度到提供GPU加速的节点上，需要约束pod的调度。这可以通过节点标签和节点标签选择器完成。</p>
<h3 id="3-5-1-使用标签分类工作节点-72"><a href="#3-5-1-使用标签分类工作节点-72" class="headerlink" title="3.5.1 使用标签分类工作节点 72"></a>3.5.1 使用标签分类工作节点 72</h3><p>pod并不是唯一可以附加标签的k8s资源。标签可以附加到任何k8s对象上，包括节点。 </p>
<h3 id="3-5-2-将-pod-调度到特定节点-72"><a href="#3-5-2-将-pod-调度到特定节点-72" class="headerlink" title="3.5.2 将 pod 调度到特定节点 72"></a>3.5.2 将 pod 调度到特定节点 72</h3><p>在spec部分添加了一个<code>nodeSelector</code>字段。当创建该pod时，调度器将只在包含标签gpu=true的节点中选择。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">spec:</span><br><span class="line">  nodeSelector:</span><br><span class="line">    gpu: &quot;true&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="3-5-3-调度到一个特定节点-73"><a href="#3-5-3-调度到一个特定节点-73" class="headerlink" title="3.5.3 调度到一个特定节点 73"></a>3.5.3 调度到一个特定节点 73</h3><p>也可以将pod调度到某个确定的节点，由于每个节点都有一个唯一标签，其中键为<code>kubernetes.io/hostname</code>， 值为该节点的实际主机名， 因此也可以将pod调度到某个确定的节点。但如果节点处于离线状态，通过hostname标签将nodeSelector设置为特定节点可能会导致pod不可调度。所以绝不应该考虑单个节点，而是应该通过标签选择器考虑符合特定标准的逻辑节点组。</p>
<h2 id="3-6-注解-pod-73"><a href="#3-6-注解-pod-73" class="headerlink" title="3.6 注解 pod 73"></a>3.6 注解 pod 73</h2><p>pod和其它对象还可以包含注解。注解也是键值对。但是注解不能像标签一样用于对对象分组。不存在注解选择器这样的东西。</p>
<h3 id="3-6-1-查找对象的注解-74"><a href="#3-6-1-查找对象的注解-74" class="headerlink" title="3.6.1 查找对象的注解 74"></a>3.6.1 查找对象的注解 74</h3><p>注解可以包含相对更多的数据，标签则是应该比较简短的。</p>
<h3 id="3-6-2-添加和修改注解-74"><a href="#3-6-2-添加和修改注解-74" class="headerlink" title="3.6.2 添加和修改注解 74"></a>3.6.2 添加和修改注解 74</h3><p>通过<code>kubectl annotate</code>命令添加和修改注解。</p>
<h2 id="3-7-使用命名空间对资源进行分组-75"><a href="#3-7-使用命名空间对资源进行分组-75" class="headerlink" title="3.7 使用命名空间对资源进行分组 75"></a>3.7 使用命名空间对资源进行分组 75</h2><p>k8s中可供声明的类称为资源（Resource），包括 pod、rs、deployment 等。声明一个资源构成的实例都有名字，这些名字都归属于一个个的命名空间之中（namespace），互不影响。</p>
<h3 id="3-7-1-了解对命名空间的需求-75"><a href="#3-7-1-了解对命名空间的需求-75" class="headerlink" title="3.7.1 了解对命名空间的需求 75"></a>3.7.1 了解对命名空间的需求 75</h3><p>在使用多个namespace的前提下，可以将包含大量组件的复杂系统拆分为更小的不同组，这些不同组也可以用于在多租户环境中分配资源，将资源分配为生产、开发和QA环境。两个不同命名空间可以包含同名资源。</p>
<blockquote>
<p>我们在业务上也这样使用过，为了减小硬件开销，开发和QA环境使用同一套k8s集群，使用不同的namespace区分。</p>
</blockquote>
<h3 id="3-7-2-发现其他命名空间及其-pod-75"><a href="#3-7-2-发现其他命名空间及其-pod-75" class="headerlink" title="3.7.2 发现其他命名空间及其 pod 75"></a>3.7.2 发现其他命名空间及其 pod 75</h3><p>命名空间除了为资源名称提供了一个作用域，也可用于仅允许某些用户访问某些特定资源，甚至限制单个用户可用的计算资源数量。</p>
<h3 id="3-7-3-创建一个命名空间-76"><a href="#3-7-3-创建一个命名空间-76" class="headerlink" title="3.7.3 创建一个命名空间 76"></a>3.7.3 创建一个命名空间 76</h3><p>k8s中的所有资源都是一个API对象。命名空间同理，所以创建namespace也可以用YAML文件描述，使用<code>kubectl create -f xxx.yaml</code>创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: custom-namespace</span><br></pre></td></tr></table></figure>

<p>也可以通过<code>kubectl create namespace</code>命令创建。</p>
<h3 id="3-7-4-管理其他命名空间中的对象-77"><a href="#3-7-4-管理其他命名空间中的对象-77" class="headerlink" title="3.7.4 管理其他命名空间中的对象 77"></a>3.7.4 管理其他命名空间中的对象 77</h3><p>在列出、描述、创建、修改、删除等操作中，需要给<code>kubectl</code>命令传递<code>--namespace</code>。否则<code>kubectl</code>在当前上下文中配置的默认命名空间执行操作。</p>
<p>当前上下文的命名空间可以通过<code>kubectl config</code>修改。要想快速切换到不同的命名空间，可以设置以下别名：<code>alias kcd=&#39;kubectl config set-context $(kubectl config current-context) --namespace&#39;</code>。然后使用<code>kcd some-namespace</code>在命名空间之间进行切换。</p>
<h3 id="3-7-5-命名空间提供的隔离-78"><a href="#3-7-5-命名空间提供的隔离-78" class="headerlink" title="3.7.5 命名空间提供的隔离 78"></a>3.7.5 命名空间提供的隔离 78</h3><p>你需要首先创建命名空间，然后再创建资源。</p>
<p>k8s 包含三个预设的命名空间：</p>
<ul>
<li>default</li>
<li>kube-public</li>
<li>kube-system</li>
</ul>
<p>命名空间之间是否网络隔离依赖于k8s使用的NetworkPolicy的配置。</p>
<h2 id="3-8-停止和移除-pod-78"><a href="#3-8-停止和移除-pod-78" class="headerlink" title="3.8 停止和移除 pod 78"></a>3.8 停止和移除 pod 78</h2><h3 id="3-8-1-按名称删除-pod-78"><a href="#3-8-1-按名称删除-pod-78" class="headerlink" title="3.8.1 按名称删除 pod 78"></a>3.8.1 按名称删除 pod 78</h3><p>在删除pod的过程中，实际上我们指示k8s终止该pod中的所有容器。k8s会向进程发送SIGTERM信号并等待一定时间，使其正常关闭（所以为了确保进程能正常关闭，业务代码中需要处理SIGTERM信号）。如果没有及时关闭，k8s则通过发送SIGKILL终止该进程。</p>
<h3 id="3-8-2-使用标签选择器删除-pod-79"><a href="#3-8-2-使用标签选择器删除-pod-79" class="headerlink" title="3.8.2 使用标签选择器删除 pod 79"></a>3.8.2 使用标签选择器删除 pod 79</h3><p>可以使用标签一次删除所有指定标签的pod。</p>
<h3 id="3-8-3-通过删除整个命名空间来删除-pod-80"><a href="#3-8-3-通过删除整个命名空间来删除-pod-80" class="headerlink" title="3.8.3 通过删除整个命名空间来删除 pod 80"></a>3.8.3 通过删除整个命名空间来删除 pod 80</h3><p>删除整个命名空间，pod将也会自动删除。</p>
<h3 id="3-8-4-删除命名空间中的所有-pod，但保留命名空间-80"><a href="#3-8-4-删除命名空间中的所有-pod，但保留命名空间-80" class="headerlink" title="3.8.4 删除命名空间中的所有 pod，但保留命名空间 80"></a>3.8.4 删除命名空间中的所有 pod，但保留命名空间 80</h3><p>要删除pod，还需要删除ReplicationController，否则会根据YAML描述文件自动创建新的pod。因为k8s是声明式设计。</p>
<h3 id="3-8-5-删除命名空间中的（几乎）所有资源-80"><a href="#3-8-5-删除命名空间中的（几乎）所有资源-80" class="headerlink" title="3.8.5 删除命名空间中的（几乎）所有资源 80"></a>3.8.5 删除命名空间中的（几乎）所有资源 80</h3><p><code>--all</code>删除所有内容并不是真的删除所有内容，一些资源例如secret会被保留下来，除非明确指定删除。</p>
<h2 id="3-9-本章的k8s命令"><a href="#3-9-本章的k8s命令" class="headerlink" title="3.9 本章的k8s命令"></a>3.9 本章的k8s命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">########## 查看pod ########## </span><br><span class="line"></span><br><span class="line"># 查看已部署的pod的完整YAML</span><br><span class="line">$ kubectl get pod kubia-zxzij -o yaml</span><br><span class="line"></span><br><span class="line"># 查看API对象支持的属性和解释</span><br><span class="line">$ kubectl explain pods</span><br><span class="line">$ kubectl explain pods.spec</span><br><span class="line"></span><br><span class="line"># 得到运行中的pod的完整定义</span><br><span class="line">$ kubectl get pod kubia-manual -o yaml</span><br><span class="line">$ kubectl get pod kubia-manual -o json</span><br><span class="line"></span><br><span class="line">########## 创建资源 ##########  </span><br><span class="line"></span><br><span class="line"># 从文件(YAML或JSON)创建资源</span><br><span class="line">$ kubectl create -f kubia-manual.yaml</span><br><span class="line"></span><br><span class="line">########## 查看日志 ##########  </span><br><span class="line"></span><br><span class="line"># 查看pod日志(准确地说是容器的日志)</span><br><span class="line">$ kubectl logs kubia-manual -c kubia</span><br><span class="line"></span><br><span class="line">########## 端口转发 ##########  </span><br><span class="line"></span><br><span class="line"># 将本地端口8888转发到pod端口8080</span><br><span class="line">$ kubectl port-forward kubia-manual 8888:8080</span><br><span class="line"></span><br><span class="line">########## label ##########  </span><br><span class="line"></span><br><span class="line"># 列出pod，带上标签</span><br><span class="line">$ kubectl get pod --show-labels</span><br><span class="line"></span><br><span class="line"># 列出pod，仅展示指定标签</span><br><span class="line">$ kubectl get pod -L creation_method,env</span><br><span class="line"></span><br><span class="line"># 为pod添加标签</span><br><span class="line">$ kubectl label pod kubia-manual creation_method&#x3D;manual</span><br><span class="line"></span><br><span class="line"># 为pod修改标签</span><br><span class="line">$ kubectl label pod kubia-manual-v2 env&#x3D;debug --overwrite</span><br><span class="line"></span><br><span class="line"># 列出包含creation_method标签，值等于manual的pod</span><br><span class="line">$ kubectl get pod -l creation_method&#x3D;manual</span><br><span class="line"></span><br><span class="line"># 列出包含env标签的pod</span><br><span class="line">$ kubectl get pod -l env</span><br><span class="line"></span><br><span class="line"># 列出没有env标签的pod</span><br><span class="line">$ kubectl get pod -l &#39;!env&#39;</span><br><span class="line"></span><br><span class="line"># 其它标签筛选条件</span><br><span class="line">creation_method!&#x3D;manual：选择带有creation_method标签，并且值不等于manual的pod。</span><br><span class="line">env in (prod, devel)：选择带有env标签且值为prod或devel的pod。</span><br><span class="line">env notin (prod, devel)：选择带有env标签，但其值不是prod或devel的pod。</span><br><span class="line"></span><br><span class="line"># 给节点添加标签gpu&#x3D;true</span><br><span class="line">$ kubectl label node gke-kubia-85f6-node-orrx gpu&#x3D;true</span><br><span class="line"></span><br><span class="line"># 列出只包含标签gpu&#x3D;true的节点</span><br><span class="line">$ kubectl get nodes -l gpu&#x3D;true</span><br><span class="line"></span><br><span class="line"># 列出所有节点，展示gpu标签值附加列</span><br><span class="line">$ kubectl get nodes -L gpu</span><br><span class="line"></span><br><span class="line">########## annotations ##########  </span><br><span class="line"></span><br><span class="line"># 给pod添加注解，将注解mycompany.com&#x2F;someannotation添加为值foo bar</span><br><span class="line">$ kubectl annotate pod kubia-manual mycompany.com&#x2F;someannotation&#x3D;&quot;foo bar&quot;</span><br><span class="line"></span><br><span class="line"># 查看pod的注解</span><br><span class="line">$ kubectl describe pod kubia-manual | grep annotations</span><br><span class="line"></span><br><span class="line">########## namespace ##########</span><br><span class="line"></span><br><span class="line"># 列出所有命名空间</span><br><span class="line">$ kubectl get ns</span><br><span class="line"></span><br><span class="line"># 列出属于命名空间kube-system的pod</span><br><span class="line">$ kubectl get pod --namespace kube-system（--namespace的缩写是-n）</span><br><span class="line"></span><br><span class="line"># 创建命名空间</span><br><span class="line">$ kubectl create namespace custom-namespace</span><br><span class="line"></span><br><span class="line">########## 删除资源 ##########</span><br><span class="line"></span><br><span class="line"># 删除pod</span><br><span class="line">$ kubectl delete pod kubia-gpu</span><br><span class="line"></span><br><span class="line"># 删除指定标签的pod</span><br><span class="line">$ kubectl delete pod -l create_method&#x3D;manual</span><br><span class="line"></span><br><span class="line"># 删除指定命名空间</span><br><span class="line">$ kubectl delete ns custom-namespace</span><br><span class="line"></span><br><span class="line"># 删除当前命名空间中的所有pod</span><br><span class="line">$ kubectl delete pod --all</span><br><span class="line"></span><br><span class="line"># 删除当前命名空间的所有资源(并不是真的删除所有内容)</span><br><span class="line">$ kubectl delete all --all</span><br></pre></td></tr></table></figure>

<h1 id="4-副本机制和其他控制器-：部署托管的-pod-83"><a href="#4-副本机制和其他控制器-：部署托管的-pod-83" class="headerlink" title="4 副本机制和其他控制器 ：部署托管的 pod 83"></a>4 副本机制和其他控制器 ：部署托管的 pod 83</h1><p>前三章比较基础，从这一章开始，事情变得有趣起来。</p>
<p>通过创建ReplicationControlle或Deployment这样的资源，由它们来创建并管理实际的pod。kubelet会保持该节点上的pod健康。</p>
<h2 id="4-1-保持-pod-健康-84"><a href="#4-1-保持-pod-健康-84" class="headerlink" title="4.1 保持 pod 健康 84"></a>4.1 保持 pod 健康 84</h2><h3 id="4-1-1-介绍存活探针-84"><a href="#4-1-1-介绍存活探针-84" class="headerlink" title="4.1.1 介绍存活探针 84"></a>4.1.1 介绍存活探针 84</h3><p>k8s可以通过存活探针(liveness probe)检查容器是否还在与进行。可以为pod中的每个容器单独指定存活探针，如果探测失败，k8s将定期执行探针并重新启动容器。</p>
<p>k8s有三种探测容器的机制（在spec内定义livenessProbe）：</p>
<ul>
<li>HTTP GET 探针：是否能正确响应GET请求。</li>
<li>TCP 探针：是否能建立TCP连接。</li>
<li>exec 探针：在容器内执行指定命令并检查退出状态码。</li>
</ul>
<h3 id="4-1-2-创建基于-HTTP-的存活探针-85"><a href="#4-1-2-创建基于-HTTP-的存活探针-85" class="headerlink" title="4.1.2 创建基于 HTTP 的存活探针 85"></a>4.1.2 创建基于 HTTP 的存活探针 85</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: luksa&#x2F;kubia-unhealthy</span><br><span class="line">    name: kubia</span><br><span class="line">    livenessProbe:</span><br><span class="line">      httpGet:</span><br><span class="line">        path: &#x2F;</span><br><span class="line">        port: 8080</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="4-1-3-使用存活探针-86"><a href="#4-1-3-使用存活探针-86" class="headerlink" title="4.1.3 使用存活探针 86"></a>4.1.3 使用存活探针 86</h3><p>通过<code>kubectl describe</code>查看为什么必须「重启」容器。不是真的重启，是创建一个新的容器。</p>
<p><code>Exit Code</code>的值减去128是终止进程的信号编号。比如<code>Exit Code</code>是137，表示因为SIGKILL(9)信号被终止。</p>
<h3 id="4-1-4-配置存活探针的附加属性-87"><a href="#4-1-4-配置存活探针的附加属性-87" class="headerlink" title="4.1.4 配置存活探针的附加属性 87"></a>4.1.4 配置存活探针的附加属性 87</h3><p>其它属性，包括delay、timeout、period等。</p>
<p>例如可用<code>initialDelaySeconds</code>自定义初始延迟。务必记得设置一个初始延迟来说明应用程序的启动时间。否则容器可能不断被重启。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">    livenessProbe:</span><br><span class="line">      httpGet:</span><br><span class="line">        path: &#x2F;</span><br><span class="line">        port: 8080</span><br><span class="line">      initialDelaySeconds: 15</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="4-1-5-创建有效的存活探针-88"><a href="#4-1-5-创建有效的存活探针-88" class="headerlink" title="4.1.5 创建有效的存活探针 88"></a>4.1.5 创建有效的存活探针 88</h3><p>一定要检查应用程序的内部，而没有外部因素的影响，比如不能调用在其它pod的数据库容器。并且保证存活探针轻量，也无需在探针中实现重式循环。</p>
<h2 id="4-2-了解-ReplicationController-89"><a href="#4-2-了解-ReplicationController-89" class="headerlink" title="4.2 了解 ReplicationController 89"></a>4.2 了解 ReplicationController 89</h2><p>ReplicationController已经完全被ReplicaSet替代，阅读了一下但不再赘述。</p>
<h2 id="4-3-使用-ReplicaSet-而不是-ReplicationController-104"><a href="#4-3-使用-ReplicaSet-而不是-ReplicationController-104" class="headerlink" title="4.3 使用 ReplicaSet 而不是 ReplicationController 104"></a>4.3 使用 ReplicaSet 而不是 ReplicationController 104</h2><p>通常不会直接创建ReplicaSet，而是通过在创建Deployment资源（在后面章节讲）时创建。</p>
<p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/" target="_blank" rel="noopener">replicaset的官方文档</a></p>
<h3 id="4-3-1-比较-ReplicaSet-和-ReplicationController-104"><a href="#4-3-1-比较-ReplicaSet-和-ReplicationController-104" class="headerlink" title="4.3.1 比较 ReplicaSet 和 ReplicationController 104"></a>4.3.1 比较 ReplicaSet 和 ReplicationController 104</h3><p>ReplicaSet的标签选择器的表达能力比ReplicationController更强。</p>
<h3 id="4-3-2-定义-ReplicaSet-105"><a href="#4-3-2-定义-ReplicaSet-105" class="headerlink" title="4.3.2 定义 ReplicaSet 105"></a>4.3.2 定义 ReplicaSet 105</h3><p>ReplicaSet不是v1 API的一部分，但属于apps API组的v1beta2版本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1beta2</span><br><span class="line">kind: ReplicaSet</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: kubia</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: kubia</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kubia</span><br><span class="line">        image: luksa&#x2F;kubia</span><br></pre></td></tr></table></figure>

<h3 id="4-3-3-创建和检查-ReplicaSet-106"><a href="#4-3-3-创建和检查-ReplicaSet-106" class="headerlink" title="4.3.3 创建和检查 ReplicaSet 106"></a>4.3.3 创建和检查 ReplicaSet 106</h3><p>使用<code>kubectl create</code>命令根据YAML文件创建ReplicaSet。</p>
<h3 id="4-3-4-使用-ReplicaSet-的更富表达力的标签选择器-106"><a href="#4-3-4-使用-ReplicaSet-的更富表达力的标签选择器-106" class="headerlink" title="4.3.4 使用 ReplicaSet 的更富表达力的标签选择器 106"></a>4.3.4 使用 ReplicaSet 的更富表达力的标签选择器 106</h3><p>rs和rc相比最大的改动就是支持更为强大复杂的标签选择器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">selector:</span><br><span class="line">  matchExpressions:</span><br><span class="line">    - key: app</span><br><span class="line">    - operator: In</span><br><span class="line">      values:</span><br><span class="line">        - kubia</span><br></pre></td></tr></table></figure>

<p>可以在<code>selector</code>中使用<code>matchExpressions</code>，支持的<code>operator</code>有：</p>
<ul>
<li>In：pod的label在指定labels之中。</li>
<li>NotIn：不在指定labels中。</li>
<li>Exists：指定的label key存在。</li>
<li>DoesNotExist：指定的label key不存在。</li>
</ul>
<p>如果你指定了多个表达式，则所有这些表达式都必须为true才能使选择器与pod匹配。如果同时指定matchLabels和matchExpressions，则所有标签都必须匹配，并且所有表达式必须计算为true以使该pod与选择器匹配。</p>
<h3 id="4-3-5-ReplicaSet-小结-107"><a href="#4-3-5-ReplicaSet-小结-107" class="headerlink" title="4.3.5 ReplicaSet 小结 107"></a>4.3.5 ReplicaSet 小结 107</h3><p>删除ReplicaSet会删除所有的pod。</p>
<h2 id="4-4-使用-DaemonSet-在每个节点上运行一个-pod-107"><a href="#4-4-使用-DaemonSet-在每个节点上运行一个-pod-107" class="headerlink" title="4.4 使用 DaemonSet 在每个节点上运行一个 pod 107"></a>4.4 使用 DaemonSet 在每个节点上运行一个 pod 107</h2><p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/daemonset/" target="_blank" rel="noopener">daemonset的官方文档</a></p>
<h3 id="4-4-1-使用-DaemonSet-在每个节点上运行一个-pod-108"><a href="#4-4-1-使用-DaemonSet-在每个节点上运行一个-pod-108" class="headerlink" title="4.4.1 使用 DaemonSet 在每个节点上运行一个 pod 108"></a>4.4.1 使用 DaemonSet 在每个节点上运行一个 pod 108</h3><p>使用DaemonSet在每个节点上运行一个pod。一般用于运行一些基础组件，如kube-proxy、日志组件等。</p>
<p>DaemonSet没有期望的副本数的概念，它的工作是确保一个pod匹配它的选择器并在每个节点上运行。如果节点下线，DaemonSet不会在其它地方重新创建pod。但是当一个新节点加入到集群中，DaemonSet会立即部署一个新的pod实例。</p>
<h3 id="4-4-2-使用-DaemonSet-只在特定的节点上运行-pod-109"><a href="#4-4-2-使用-DaemonSet-只在特定的节点上运行-pod-109" class="headerlink" title="4.4.2 使用 DaemonSet 只在特定的节点上运行 pod 109"></a>4.4.2 使用 DaemonSet 只在特定的节点上运行 pod 109</h3><p>通过pod模板中的nodeSelector属性指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: apps&#x2F;v1beta2</span><br><span class="line">kind: DaemonSet</span><br><span class="line">metadata:</span><br><span class="line">  name: ssd-monitor</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: ssd-monitor</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: ssd-monitor</span><br><span class="line">    spec:</span><br><span class="line">      nodeSelector:</span><br><span class="line">        disk: ssd</span><br><span class="line">      containers:</span><br><span class="line">      - name: main</span><br><span class="line">        image: luksa&#x2F;ssd-monitor</span><br></pre></td></tr></table></figure>

<h2 id="4-5-运行执行单个任务的-pod-112"><a href="#4-5-运行执行单个任务的-pod-112" class="headerlink" title="4.5 运行执行单个任务的 pod 112"></a>4.5 运行执行单个任务的 pod 112</h2><p>前面提到的ReplicationController、ReplicaSet、DaemonSet都会持续运行任务，永远达不到完成态。k8s通过Job资源提供了可完成任务的支持，其进程正常终止后，不重新启动。</p>
<p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/" target="_blank" rel="noopener">Job的官方文档</a></p>
<h3 id="4-5-1-介绍-Job-资源-112"><a href="#4-5-1-介绍-Job-资源-112" class="headerlink" title="4.5.1 介绍 Job 资源 112"></a>4.5.1 介绍 Job 资源 112</h3><p>Job可以调度pod来运行一次性的任务，程序运行成功退出后，不重启容器。一旦任务完成，pod就被认为处于完成状态。</p>
<p>如果pod在被调度的节点上异常退出后，由Job管理的pod会一直被重新安排，直到成功完成任务。</p>
<h3 id="4-5-2-定义-Job-资源-113"><a href="#4-5-2-定义-Job-资源-113" class="headerlink" title="4.5.2 定义 Job 资源 113"></a>4.5.2 定义 Job 资源 113</h3><p>重启策略<code>restartPolicy</code>默认为Always。Job pod不能使用默认策略。需要明确将其设置为<code>OnFailure</code>或<code>Never</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: batch&#x2F;v1</span><br><span class="line">kind: Job</span><br><span class="line">metadata:</span><br><span class="line">  name: batch-job</span><br><span class="line">spec:</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: batch-job</span><br><span class="line">    spec:</span><br><span class="line">      restartPolicy: OnFailure</span><br><span class="line">      containers:</span><br><span class="line">      - name: main</span><br><span class="line">        image: luksa&#x2F;batch-job</span><br></pre></td></tr></table></figure>

<h3 id="4-5-3-看-Job-运行一个-pod-114"><a href="#4-5-3-看-Job-运行一个-pod-114" class="headerlink" title="4.5.3 看 Job 运行一个 pod 114"></a>4.5.3 看 Job 运行一个 pod 114</h3><p>完成后的pod STATUS是Completed，并且不被删除。除非手动删除pod，或者删除创建它的Job。</p>
<h3 id="4-5-4-在-Job-中运行多个-pod-实例-114"><a href="#4-5-4-在-Job-中运行多个-pod-实例-114" class="headerlink" title="4.5.4 在 Job 中运行多个 pod 实例 114"></a>4.5.4 在 Job 中运行多个 pod 实例 114</h3><p>通过在Job配置中设置<code>completions</code>和<code>parallelism</code>属性，可以以并行或串行方式运行多个pod。</p>
<ul>
<li>顺序运行Job pod</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: batch&#x2F;v1</span><br><span class="line">kind: Job</span><br><span class="line">metadata:</span><br><span class="line">  name: multi-completion-batch-job</span><br><span class="line">spec:</span><br><span class="line">  completions: 5</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: batch-job</span><br><span class="line">    spec:</span><br><span class="line">      restartPolicy: OnFailure</span><br><span class="line">      containers:</span><br><span class="line">      - name: main</span><br><span class="line">        image: luksa&#x2F;batch-job</span><br></pre></td></tr></table></figure>

<ul>
<li>并行运行Job pod</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: batch&#x2F;v1</span><br><span class="line">kind: Job</span><br><span class="line">metadata:</span><br><span class="line">  name: multi-completion-batch-job</span><br><span class="line">spec:</span><br><span class="line">  completions: 5</span><br><span class="line">  parallelism: 2</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: batch-job</span><br><span class="line">    spec:</span><br><span class="line">      restartPolicy: OnFailure</span><br><span class="line">      containers:</span><br><span class="line">      - name: main</span><br><span class="line">        image: luksa&#x2F;batch-job</span><br></pre></td></tr></table></figure>

<p>通过<code>kubectl scale</code>命令更改<code>parallelism</code>属性，Job可以在运行过程中被缩放。</p>
<h3 id="4-5-5-限制-Job-pod-完成任务的时间-116"><a href="#4-5-5-限制-Job-pod-完成任务的时间-116" class="headerlink" title="4.5.5 限制 Job pod 完成任务的时间 116"></a>4.5.5 限制 Job pod 完成任务的时间 116</h3><p>通过<code>activeDeadlineSeconds</code>属性，限制pod运行的时间。<br>通过<code>spec.backoffLimit</code>属性，配置Job在被标记为失败之前可以重试的次数。默认为6。</p>
<h2 id="4-6-安排-Job-定期运行或在将来运行一次-116"><a href="#4-6-安排-Job-定期运行或在将来运行一次-116" class="headerlink" title="4.6 安排 Job 定期运行或在将来运行一次 116"></a>4.6 安排 Job 定期运行或在将来运行一次 116</h2><p>k8s用CronJob资源设置cron任务。</p>
<p><a href="https://kubernetes.io/docs/concepts/workloads/controllers/cron-jobs/" target="_blank" rel="noopener">CronJob的官方文档</a></p>
<h3 id="4-6-1-创建一个-CronJob-116"><a href="#4-6-1-创建一个-CronJob-116" class="headerlink" title="4.6.1 创建一个 CronJob 116"></a>4.6.1 创建一个 CronJob 116</h3><p>CronJob通过<code>jobTemplate</code>模板创建资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: batch&#x2F;v1beta1</span><br><span class="line">kind: CronJob</span><br><span class="line">metadata:</span><br><span class="line">  name: batch-job-every-fifteen-minutes</span><br><span class="line">spec:</span><br><span class="line">  schedule: &quot;0,15,30,45 * * * *&quot;</span><br><span class="line">  jobTemplate:</span><br><span class="line">    spec:</span><br><span class="line">      template:</span><br><span class="line">        metadata:</span><br><span class="line">          labels:</span><br><span class="line">            app: periodic-batch-job</span><br><span class="line">        spec:</span><br><span class="line">          restartPolicy: OnFailure</span><br><span class="line">          containers:</span><br><span class="line">          - name: main</span><br><span class="line">            image: luksa&#x2F;batch-job</span><br></pre></td></tr></table></figure>

<h3 id="4-6-2-了解计划任务的运行方式-118"><a href="#4-6-2-了解计划任务的运行方式-118" class="headerlink" title="4.6.2 了解计划任务的运行方式 118"></a>4.6.2 了解计划任务的运行方式 118</h3><p>在计划的时间内，CronJob资源会创建Job资源，然后Job创建pod。</p>
<p>可以通过指定CronJob规范中的<code>startingDeadlineSeconds</code>字段来指定截止时间。</p>
<p>CronJob总是为计划中配置的每个执行创建一个Job，但可能会同时创建两个Job，或者根本没有创建。为了解决第一个问题，你的任务应该是幂等的（多次而不是一次运行不会得到不希望的结果）。对于第二个问题，请确保下一个任务运行完成本应该由上一次的（错过的）运行完成的任何工作。</p>
<h2 id="4-7-本章的k8s命令-118"><a href="#4-7-本章的k8s命令-118" class="headerlink" title="4.7 本章的k8s命令 118"></a>4.7 本章的k8s命令 118</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">########## 日志 ##########</span><br><span class="line"></span><br><span class="line"># 获取前一个容器的日志</span><br><span class="line">$ kubectl logs mypod --previous</span><br><span class="line"></span><br><span class="line">########## ReplicationController ##########</span><br><span class="line"></span><br><span class="line"># 编辑模板</span><br><span class="line">$ kubectl edit rc kubia</span><br><span class="line"></span><br><span class="line"># 对管理的pod数量伸缩，等于修改spec.replicas&#x3D;3</span><br><span class="line">$ kubectl scale rc kubia --replicas&#x3D;3</span><br><span class="line"></span><br><span class="line"># 删除rc使pod不受管理但保持运行</span><br><span class="line">$ kubectl delete rc kubia --cascade&#x3D;false</span><br><span class="line"></span><br><span class="line">########## ReplicaSet ##########</span><br><span class="line"></span><br><span class="line"># 查看ReplicaSet</span><br><span class="line">$ kubectl get rs</span><br><span class="line"></span><br><span class="line"># 描述ReplicaSet</span><br><span class="line">$ kubectl describe rs</span><br><span class="line"></span><br><span class="line"># 删除ReplicaSet</span><br><span class="line">$ kubectl delete rs kubia</span><br><span class="line"></span><br><span class="line">########## DaemonSet ##########</span><br><span class="line"></span><br><span class="line"># 查看DaemonSet</span><br><span class="line">$ kubectl get ds</span><br><span class="line"></span><br><span class="line">########## node ##########</span><br><span class="line"></span><br><span class="line"># 给节点添加标签</span><br><span class="line">$ kubectl label node minikube disk&#x3D;ssd</span><br><span class="line"></span><br><span class="line"># 从节点删除标签</span><br><span class="line">$ kubectl label node minikube disk&#x3D;hdd --overwrite</span><br><span class="line"></span><br><span class="line">########## Job ##########</span><br><span class="line"></span><br><span class="line"># 查看Job</span><br><span class="line">$ kubectl get jobs</span><br><span class="line"></span><br><span class="line"># 查看所有pod包括已经完成的</span><br><span class="line">$ kubectl get pod --show-all(缩写-a)</span><br><span class="line"></span><br><span class="line"># 将Job并行度改成3</span><br><span class="line">$ kubectl scale job multi-completion-batch-job --replicas 3</span><br></pre></td></tr></table></figure>

<h1 id="5-服务-：让客户端发现-pod-并与之通信-121"><a href="#5-服务-：让客户端发现-pod-并与之通信-121" class="headerlink" title="5 服务 ：让客户端发现 pod 并与之通信 121"></a>5 服务 ：让客户端发现 pod 并与之通信 121</h1><p>pod会在node间被调度，一组功能相同的pod需要对外提供一个稳定地址，而service就是pod对外的门户。</p>
<p><a href="https://kubernetes.io/docs/concepts/services-networking/service/" target="_blank" rel="noopener">service的官方文档</a></p>
<h2 id="5-1-介绍服务-122"><a href="#5-1-介绍服务-122" class="headerlink" title="5.1 介绍服务 122"></a>5.1 介绍服务 122</h2><p>service会通过selector绑定多个pod，service通过clusterIP对外接收请求，然后分配给绑定的pod。</p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/11.png">

<h3 id="5-1-1-创建服务-123"><a href="#5-1-1-创建服务-123" class="headerlink" title="5.1.1 创建服务 123"></a>5.1.1 创建服务 123</h3><p>通过<code>kubectl expose</code>命令或者YAML文件描述创建service均可。</p>
<p>例如创建一个名叫kubia的service。它将在端口80接收请求并将连接路由到具有标签选择器<code>app=kubia</code>的pod的8080端口上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80 # 该服务的可用端口</span><br><span class="line">    targetPort: 8080 # 服务将连接转发到的容器端口</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia # 具有app&#x3D;kubia标签的pod都属于该服务</span><br></pre></td></tr></table></figure>

<p><code>kubectl exec</code>命令可以在一个存在的pod中运行命令。</p>
<p>如果希望特定客户端产生的所有请求每次都指向同一个 pod，可以设置服务的<code>sessionAffinity</code>属性为<code>ClientIP</code>。<br>k8s仅仅支持两种形式的会话亲和性服务： None 和 ClientIP。默认值None。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">spec:</span><br><span class="line">  sessionAffinity: ClientIP</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<p>k8s服务不是在HTTP层工作，服务处理TCP/UDP包，并不关心包的内容，所以k8s不支持基于cookie(HTTP协议的一部分)的会话亲和性选项。</p>
</blockquote>
<p>同一个服务可以暴露多个端口，但必须给每个端口指定名字。标签选择器应用于整个服务，不能对每个端口做单独的配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    port: 80</span><br><span class="line">    targetPort: 8080</span><br><span class="line">  - name: https</span><br><span class="line">    port: 443</span><br><span class="line">    targetPort: 8443</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br></pre></td></tr></table></figure>

<p>可以在pod中定义port的名称，这样可以在service中按名称引用这些端口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">kind: pod</span><br><span class="line">spec:</span><br><span class="line">  container:</span><br><span class="line">  - name: kubia</span><br><span class="line">    ports:</span><br><span class="line">    - name: http</span><br><span class="line">      containerPort: 8080</span><br><span class="line">    - name: https</span><br><span class="line">      containerPort: 8443</span><br><span class="line">---</span><br><span class="line">kind: Service</span><br><span class="line">spec:</span><br><span class="line">  ports:</span><br><span class="line">  - name: http</span><br><span class="line">    port: 80</span><br><span class="line">    targetPort: http</span><br><span class="line">  - name: https</span><br><span class="line">    port: 443</span><br><span class="line">    targetPort: https</span><br></pre></td></tr></table></figure>

<h3 id="5-1-2-服务发现-129"><a href="#5-1-2-服务发现-129" class="headerlink" title="5.1.2 服务发现 129"></a>5.1.2 服务发现 129</h3><p>在服务后面的pod可能删除重建，它们的IP地址可能改变，数量也会增减，但是始终可以通过服务的单一不变的IP地址访问到这些pod。</p>
<ul>
<li>可以通过环境变量获取服务IP地址和端口号。</li>
<li>可以通过DNS发现服务（推荐）。但是客户端必须知道服务的端口号。</li>
</ul>
<p>service的DNS地址为<code>&lt;service_name&gt;.&lt;namespace&gt;.svc.cluster.local</code>。<code>svc.cluster.local</code>是在所有集群本地服务名称中使用的可配置集群域后缀，可以省略。</p>
<p>k8s有一个kube-dns的pod，作为集群的DNS服务。集群中的其它pod都被配置成使用其作为DNS服务器(通过修改每个容器的<code>/etc/resolv.conf</code>文件实现)。pod是否使用内部的DNS服务器根据<code>spec.dnsPolicy</code>决定。</p>
<blockquote>
<p>创建service时会自动地创建DNS记录，DNS里会记录和service关联的所有pods的IP。这一特性非常的有用，比如如果你想要在prometheus里监听某个daemonset，那么就可以为这些daemonset配置一个svc，然后让prometheus通过dns_sd_configs（基于DNS的服务发现）去自动发现所有的daemonset pods。</p>
</blockquote>
<h2 id="5-2-连接集群外部的服务-132"><a href="#5-2-连接集群外部的服务-132" class="headerlink" title="5.2 连接集群外部的服务 132"></a>5.2 连接集群外部的服务 132</h2><h3 id="5-2-1-介绍服务-endpoint-133"><a href="#5-2-1-介绍服务-endpoint-133" class="headerlink" title="5.2.1 介绍服务 endpoint 133"></a>5.2.1 介绍服务 endpoint 133</h3><p>服务并不是和 pod 直接相连的。有一种资源介于两者之间——它就是Endpoint资源。<br>service创建endpoint，并且将流量导向 endpoint。</p>
<blockquote>
<p>Pods expose themselves through endpoints to a service. </p>
</blockquote>
<h3 id="5-2-2-手动配置服务的-endpoint-133"><a href="#5-2-2-手动配置服务的-endpoint-133" class="headerlink" title="5.2.2 手动配置服务的 endpoint 133"></a>5.2.2 手动配置服务的 endpoint 133</h3><p>尽管在spec服务中定义了pod选择器，但在重定向传入连接时不会直接使用它。相反，选择器用于构建IP和端口列表，然后存储在Endpoint资源中。当客户端连接到服务时，服务代理选择这些IP和端口对中的一个。</p>
<p>selector用于构建endpoint，svc直接从endpoint中选择一个地址来使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: external-service # service的名称必须和endpoint的名字匹配</span><br><span class="line">spec: # 因为不需要匹配到pods，所以无需定义selector</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Endpoints</span><br><span class="line">metadata:</span><br><span class="line">  name: external-service # endpoint的名称必须和service的名称匹配</span><br><span class="line">subsets:</span><br><span class="line">  - addresses:</span><br><span class="line">    - ip: 11.11.11.11 # service将会将请求重定向的地址</span><br><span class="line">    - ip: 22.22.22.22</span><br><span class="line">    ports:</span><br><span class="line">    - port: 80 # endpoint的目标端口</span><br></pre></td></tr></table></figure>

<img width="600" src="/images/Kubernetes In Action阅读笔记/12.png">

<h3 id="5-2-3-为外部服务创建别名-135"><a href="#5-2-3-为外部服务创建别名-135" class="headerlink" title="5.2.3 为外部服务创建别名 135"></a>5.2.3 为外部服务创建别名 135</h3><p>要创建一个具有别名的外部服务的服务时，将创建service资源的<code>type</code>字段设置为<code>ExternalName</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: external-service</span><br><span class="line">spec:</span><br><span class="line">  type: ExternalName</span><br><span class="line">  externalName: api.somecompany.com # 实际服务的完全限定域名</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br></pre></td></tr></table></figure>

<h2 id="5-3-将服务暴露给外部客户端-136"><a href="#5-3-将服务暴露给外部客户端-136" class="headerlink" title="5.3 将服务暴露给外部客户端 136"></a>5.3 将服务暴露给外部客户端 136</h2><h3 id="5-3-1-使用-NodePort-类型的服务-137"><a href="#5-3-1-使用-NodePort-类型的服务-137" class="headerlink" title="5.3.1 使用 NodePort 类型的服务 137"></a>5.3.1 使用 NodePort 类型的服务 137</h3><p>通过创建<code>NodePort</code>类型的服务，可以让k8s在其所有节点上保留一个端口（所有节点上都使用相同的端口号），并将传入的连接转发给作为服务部分的pod。</p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/13.png">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-nodeport</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    targetPort: 8080</span><br><span class="line">    nodePort: 30123</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br></pre></td></tr></table></figure>

<p>EXTERNAL-IP列显示nodes，表明服务可通过任何集群节点的IP地址访问。</p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/14.png">

<h3 id="5-3-2-通过负载均衡器将服务暴露出来-140"><a href="#5-3-2-通过负载均衡器将服务暴露出来-140" class="headerlink" title="5.3.2 通过负载均衡器将服务暴露出来 140"></a>5.3.2 通过负载均衡器将服务暴露出来 140</h3><p>在EKS或GKE等云端使用k8s服务时，可以将服务的类型设置成<code>LoadBalance</code>，直接将服务绑定到云上的lb上。</p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/15.png">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-loadbalancer</span><br><span class="line">spec:</span><br><span class="line">  type: LoadBalancer</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    targetPort: 8080</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br></pre></td></tr></table></figure>

<p>EXTERNAL-IP列显示的是lb的IP，可以通过该IP访问服务。</p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/16.png">

<h3 id="5-3-3-了解外部连接的特性-142"><a href="#5-3-3-了解外部连接的特性-142" class="headerlink" title="5.3.3 了解外部连接的特性 142"></a>5.3.3 了解外部连接的特性 142</h3><p>可以通过将服务配置为仅将外部通信重定向到接收连接的节点上运行的pod来阻止此额外跳数。这是通过在服务的spec部分中设置<code>externalTrafficPolicy</code>字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  externalTrafficPolicy: Local</span><br></pre></td></tr></table></figure>

<h2 id="5-4-通过-Ingress-暴露服务-143"><a href="#5-4-通过-Ingress-暴露服务-143" class="headerlink" title="5.4 通过 Ingress 暴露服务 143"></a>5.4 通过 Ingress 暴露服务 143</h2><p>除了NodePort和LoadBalance这两种向集群外部的客户端公开服务的方法，还有一种方法，创建Ingress资源。</p>
<p>每个LoadBalancer服务都需要自己的负载均衡器，以及独有的公有 IP 地址，而 Ingress 只需要一个公网IP就能为许多服务提供访问。</p>
<p>Ingress在HTTP层工作，可以提供服务不能实现的功能(service在TCP/UDP层工作)。比如基于cookie的会话亲和性(session affinity)等功能。</p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/17.png">

<p>Ingress其实就是集群的网关，一般都会使用Nginx或HAProxy，通过绑定虚拟主机的形式暴露集群内的服务。</p>
<h3 id="5-4-1-创建-Ingress-资源-145"><a href="#5-4-1-创建-Ingress-资源-145" class="headerlink" title="5.4.1 创建 Ingress 资源 145"></a>5.4.1 创建 Ingress 资源 145</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions&#x2F;v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">  - host: kubia.example.com # Ingress将域名kubia.example.com映射到你的服务</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: &#x2F; # 将所有的请求发送到kubia-nodeport服务的80端口</span><br><span class="line">        backend:</span><br><span class="line">          serviceName: kubia-nodeport</span><br><span class="line">          servicePort: 80</span><br></pre></td></tr></table></figure>

<p>定义了一个单一规则的Ingress，确保Ingress控制器收到的所有请求主机<code>kubia.example.com</code>的HTTP请求，将被发送到端口80上的kubia-nodeport服务。</p>
<h3 id="5-4-2-通过-Ingress-访问服务-146"><a href="#5-4-2-通过-Ingress-访问服务-146" class="headerlink" title="5.4.2 通过 Ingress 访问服务 146"></a>5.4.2 通过 Ingress 访问服务 146</h3><img width="600" src="/images/Kubernetes In Action阅读笔记/18.png">

<p>客户端通过Ingress控制器连接到其中一个pod的流程：</p>
<ul>
<li>客户端首先对<code>kubia.example.com</code>执行DNS查询，得到Ingress控制器的IP。</li>
<li>客户端然后向Ingress控制器发送HTTP请求，并在HTTP header指定host(<code>-H &quot;Host: kubia.example.com&quot;</code>)。</li>
<li>Ingress控制器从该头部确定客户端目标访问哪个service。</li>
<li>通过与该service关联的endpoint对象查看pod IP。</li>
<li>将客户端的请求转发给其中一个pod IP。</li>
</ul>
<blockquote>
<p><code>curl http://kubia.example.com</code>（需要在/etc/hosts添加192.168.99.100 kubia.example.com）和<code>curl http://192.168.99.100 -H &quot;Host: kubia.example.com&quot;</code>均可用来通过Ingress访问服务。</p>
</blockquote>
<h3 id="5-4-3-通过相同的-Ingress-暴露多个服务-147"><a href="#5-4-3-通过相同的-Ingress-暴露多个服务-147" class="headerlink" title="5.4.3 通过相同的 Ingress 暴露多个服务 147"></a>5.4.3 通过相同的 Ingress 暴露多个服务 147</h3><p>一个Ingress可以将多个主机和路径映射到多个服务。</p>
<ul>
<li>将不同的服务映射到相同虚拟主机的不同路径</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">- host: kubia.example.com</span><br><span class="line">  http:</span><br><span class="line">    paths:</span><br><span class="line">    - path: &#x2F;kubia</span><br><span class="line">      backend:</span><br><span class="line">        serviceName: kubia # 对kubia.example.com&#x2F;kubia的请求将会转发至kubia服务</span><br><span class="line">        servicePort: 80</span><br><span class="line">    - path: &#x2F;bar</span><br><span class="line">      backend:</span><br><span class="line">        serviceName: bar # 对kubia.example.com&#x2F;bar的请求将会转发至bar服务</span><br><span class="line">        servicePort: 80</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>将不同的服务映射到不同的虚拟主机上</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">- host: foo.example.com</span><br><span class="line">  http:</span><br><span class="line">    paths:</span><br><span class="line">    - path: &#x2F;</span><br><span class="line">      backend:</span><br><span class="line">        serviceName: foo # 对foo.example.com的请求将会转发至foo服务</span><br><span class="line">        servicePort: 80</span><br><span class="line">- host: bar.example.com</span><br><span class="line">  http:</span><br><span class="line">    paths:</span><br><span class="line">    - path: &#x2F;</span><br><span class="line">      backend:</span><br><span class="line">        serviceName: bar # 对bar.example.com的请求将会转发至bar服务</span><br><span class="line">        servicePort: 80</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="5-4-4-配置-Ingress-处理-TLS-传输-149"><a href="#5-4-4-配置-Ingress-处理-TLS-传输-149" class="headerlink" title="5.4.4 配置 Ingress 处理 TLS 传输 149"></a>5.4.4 配置 Ingress 处理 TLS 传输 149</h3><p>将证书可私钥附加到Ingress控制器。<br>当客户端创建到Ingress控制器的TLS连接时，控制器将终止TLS连接。客户端和控制器之间的通信是加密的，而控制器和后端pod之间的通信则不是。运行在pod上的应用程序不需要支持TLS。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions&#x2F;v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  tls: # 在这个属性下包含了所有的TLS的配置</span><br><span class="line">  - hosts: </span><br><span class="line">    - kubia.example.com # 将接收来自kubia.example.com主机的TLS连接</span><br><span class="line">    secretName: tls-secret # 从tls-secret中获得之前创建的私钥和证书</span><br><span class="line">  rules:</span><br><span class="line">  - host: kubia.example.com</span><br><span class="line">    http:</span><br><span class="line">      paths:</span><br><span class="line">      - path: &#x2F;</span><br><span class="line">        backend:</span><br><span class="line">          serviceName: kubia-nodeport</span><br><span class="line">          servicePort: 80</span><br></pre></td></tr></table></figure>

<h2 id="5-5-pod-就绪后发出信号-150"><a href="#5-5-pod-就绪后发出信号-150" class="headerlink" title="5.5 pod 就绪后发出信号 150"></a>5.5 pod 就绪后发出信号 150</h2><h3 id="5-5-1-介绍就绪探针-151"><a href="#5-5-1-介绍就绪探针-151" class="headerlink" title="5.5.1 介绍就绪探针 151"></a>5.5.1 介绍就绪探针 151</h3><p>就绪探针（readinessProbe）会定期调用，并确定特定的 pod 是否接收客户端请求。当容器的准备就绪探测返回成功时，表示容器已准备好接收请求。</p>
<p>和存活探针一样，就绪探针也有三种类型：</p>
<ul>
<li>Exec</li>
<li>HTTP GET</li>
<li>TCP</li>
</ul>
<p>就绪探针与存活探针最重要的区别是，如果容器未通过准备检查，则不会被终止或重新启动，只是从服务中删除该pod，如果pod再次准备就绪，则重新添加pod到服务。</p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/19.png">

<p>如果一个pod的就绪探测失败，则将该容器从端点对象中移除。连接到该服务的客户端不会被重定向到pod。这和pod与服务的标签选择器完全不匹配的效果相同。</p>
<h3 id="5-5-2-向-pod-添加就绪探针-152"><a href="#5-5-2-向-pod-添加就绪探针-152" class="headerlink" title="5.5.2 向 pod 添加就绪探针 152"></a>5.5.2 向 pod 添加就绪探针 152</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  replicas: 3</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: kubia</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: kubia</span><br><span class="line">        image: luksa&#x2F;kubia</span><br><span class="line">        ports:</span><br><span class="line">        - name: http</span><br><span class="line">          containerPort: 8080</span><br><span class="line">        readinessProbe: # pod中的每个容器都会有一个就绪探针</span><br><span class="line">          exec:</span><br><span class="line">            command:</span><br><span class="line">            - ls</span><br><span class="line">            - &#x2F;var&#x2F;ready</span><br></pre></td></tr></table></figure>

<h3 id="5-5-3-了解就绪探针的实际作用-154"><a href="#5-5-3-了解就绪探针的实际作用-154" class="headerlink" title="5.5.3 了解就绪探针的实际作用 154"></a>5.5.3 了解就绪探针的实际作用 154</h3><p>应该通过删除pod或更改pod标签而不是手动更改探针来从服务中手动移除 pod。<br>应该始终定义一个就绪探针，即使它只是向基准URL发送HTTP请求一样简单。</p>
<h2 id="5-6-使用-headless-服务来发现独立的-pod-155"><a href="#5-6-使用-headless-服务来发现独立的-pod-155" class="headerlink" title="5.6 使用 headless 服务来发现独立的 pod 155"></a>5.6 使用 headless 服务来发现独立的 pod 155</h2><p><a href="https://kubernetes.io/docs/concepts/services-networking/service/#headless-services" target="_blank" rel="noopener">headless service的官方文档</a></p>
<p>如果告诉k8s，不需要为服务提供集群IP，则DNS服务器将返回pod IP而不是单个服务IP。<br>将服务spec中的clusterIP字段设置为None会使服务成为headless服务，因为k8s不会为其分配集群IP，客户端可通过该IP将其连接到支持它的pod。<br>通常情况下，DNS查询svc会返回svc的clusterIP。而对于headless服务，DNS查询会返回一系列A记录，分别对应相应的pod的地址。</p>
<h3 id="5-6-1-创建-headless-服务-156"><a href="#5-6-1-创建-headless-服务-156" class="headerlink" title="5.6.1 创建 headless 服务 156"></a>5.6.1 创建 headless 服务 156</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-headless</span><br><span class="line">spec:</span><br><span class="line">  clusterIP: None # 这使得服务成为headless的</span><br><span class="line">  ports:</span><br><span class="line">  - port: 80</span><br><span class="line">    targetPort: 8080</span><br><span class="line">  selector:</span><br><span class="line">    app: kubia</span><br></pre></td></tr></table></figure>

<h3 id="5-6-2-通过-DNS-发现-pod-156"><a href="#5-6-2-通过-DNS-发现-pod-156" class="headerlink" title="5.6.2 通过 DNS 发现 pod 156"></a>5.6.2 通过 DNS 发现 pod 156</h3><p>非headless服务返回的DNS是服务的集群IP。<br>headless服务返回的DNS是所有就绪的pod的IP。headless服务依然提供跨pod的负载均衡。</p>
<h3 id="5-6-3-发现所有的-pod——包括未就绪的-pod-157"><a href="#5-6-3-发现所有的-pod——包括未就绪的-pod-157" class="headerlink" title="5.6.3 发现所有的 pod——包括未就绪的 pod 157"></a>5.6.3 发现所有的 pod——包括未就绪的 pod 157</h3><p>通过添加annotations，可以将所有匹配标签选择器的pod添加到服务中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  annotations:</span><br><span class="line">    service.alpha.kubernetes.io&#x2F;tolerate-unready-endpoints: &quot;true&quot;</span><br></pre></td></tr></table></figure>

<h2 id="5-7-排除服务故障-158"><a href="#5-7-排除服务故障-158" class="headerlink" title="5.7 排除服务故障 158"></a>5.7 排除服务故障 158</h2><ul>
<li>确保从集群内连接到服务的集群IP，而不是从外部。</li>
<li>不要通过ping服务IP来判断服务是否可访问(服务的集群IP是虚拟IP，是无法ping通的)。</li>
<li>如果已经定义了就绪探针，请确保它返回成功；否则该pod不会成为服务的一部分。</li>
<li>要确认某个容器是服务的一部分，请使用<code>kubectl get endpoint</code>来检查相应的端点对象。</li>
<li>如果尝试通过FQDN或其中一部分来访问服务(例如<code>myservice.mynamespace.svc.cluster.local</code>或<code>myservice.mynamespace</code>)，但不起作用，请查看是否可以使用其集群IP而不是FQDN来访问服务。</li>
<li>检查是否连接到服务公开的端口，而不是目标端口。</li>
<li>尝试直接连接到pod IP以确认pod正在接收正确端口上的连接。</li>
<li>如果甚至无法通过pod的IP访问应用，请确保应用不是仅绑定到本地主机。 </li>
</ul>
<h2 id="5-8-本章的k8s命令-159"><a href="#5-8-本章的k8s命令-159" class="headerlink" title="5.8 本章的k8s命令 159"></a>5.8 本章的k8s命令 159</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">########## Service ##########</span><br><span class="line"></span><br><span class="line"># 在一个运行的pod容器上执行curl，--代表kubectl命令的结束，之后是在pod内部需要执行的命令</span><br><span class="line">$ kubectl exec kubia-7nog1 -- curl -s http:&#x2F;&#x2F;10.111.249.153</span><br><span class="line"></span><br><span class="line"># 展示服务细节</span><br><span class="line">$ kubectl describe svc kubia</span><br><span class="line"></span><br><span class="line">########## Pod ##########</span><br><span class="line"></span><br><span class="line"># 删除所有pod</span><br><span class="line">$ kubectl delete pod --all</span><br><span class="line"></span><br><span class="line"># 在pod容器上运行bash</span><br><span class="line">$ kubectl exec -it kubia-3inly bash</span><br><span class="line"></span><br><span class="line"># 查看Ingress控制器的pod</span><br><span class="line">$ kubectl get pod --all-namespaces|grep ingress</span><br><span class="line"></span><br><span class="line"># 不通过YAML文件进行pod，直接创建pod，不需要通过rc等资源来创建</span><br><span class="line">$ kubectl run dnsutils --image&#x3D;tutum&#x2F;dnsutils --generator&#x3D;run-pod&#x2F;v1 --command -- sleep infinity</span><br><span class="line"></span><br><span class="line"># 使用pod dnsutils执行DNS查找</span><br><span class="line">$ kubectl exec dnsutils nslookup kubia-headless</span><br><span class="line"></span><br><span class="line">########## Endpoint ##########</span><br><span class="line"></span><br><span class="line"># 查看endpoint</span><br><span class="line">$ kubectl get endpoint kubia</span><br><span class="line"></span><br><span class="line">########## Node ##########</span><br><span class="line"></span><br><span class="line"># 使用JSONPath获取所有节点的IP</span><br><span class="line">$ kubectl get nodes -o jsonpath&#x3D;&#39;&#123;.items[*].status.addresses[?(@.type&#x3D;&#x3D;&quot;ExternalIP&quot;)].address&#125;&#39;</span><br><span class="line"></span><br><span class="line">########## Ingress ##########</span><br><span class="line"></span><br><span class="line"># 列出Ingress</span><br><span class="line">$ kubectl get Ingress</span><br><span class="line"></span><br><span class="line"># 更新Ingress资源</span><br><span class="line">$ kubectl apply -f kubia-ingress-tls.yaml</span><br><span class="line"></span><br><span class="line">########## Secret ##########</span><br><span class="line"></span><br><span class="line"># 创建Secret</span><br><span class="line">$ kubectl create secret tls tls-secret --cert&#x3D;tls.cert --key&#x3D;tls.key</span><br></pre></td></tr></table></figure>

<h1 id="6-卷-：将磁盘挂载到容器-161"><a href="#6-卷-：将磁盘挂载到容器-161" class="headerlink" title="6 卷 ：将磁盘挂载到容器 161"></a>6 卷 ：将磁盘挂载到容器 161</h1><p><a href="https://kubernetes.io/docs/concepts/storage/volumes/" target="_blank" rel="noopener">volume的官方文档</a></p>
<p>pod中的每个容器都有自己的独立文件系统，因为文件系统来自容器镜像。<br>k8s通过在pod中定义卷，使得存储持久化，和pod共享生命周期，而不会随着容器的重启消失。</p>
<h2 id="6-1-介绍卷-162"><a href="#6-1-介绍卷-162" class="headerlink" title="6.1 介绍卷 162"></a>6.1 介绍卷 162</h2><h3 id="6-1-1-卷的应用示例-162"><a href="#6-1-1-卷的应用示例-162" class="headerlink" title="6.1.1 卷的应用示例 162"></a>6.1.1 卷的应用示例 162</h3><p>卷被绑定到pod的lifecycle中，只有在pod存在时才会存在，但取决于卷的类型，即使在pod和卷消失之后，卷的文件也可能保待原样，并可以挂载到新的卷中。</p>
<img width="400" src="/images/Kubernetes In Action阅读笔记/20.png">

<h3 id="6-1-2-介绍可用的卷类型-164"><a href="#6-1-2-介绍可用的卷类型-164" class="headerlink" title="6.1.2 介绍可用的卷类型 164"></a>6.1.2 介绍可用的卷类型 164</h3><ul>
<li>emptyDir：用于存储临时数据的简单空目录。</li>
<li>hostPath：用于将目录从工作节点的文件系统挂载到 pod 中。</li>
<li>gitRepo：通过检出 Git 仓库的内容来初始化的卷。</li>
<li>nfs：挂载到 pod 中的 NFS 共享卷。</li>
<li>云磁盘<ul>
<li>gcePersistentDisk</li>
<li>awsElasticBlockStore</li>
<li>azureDisk</li>
</ul>
</li>
<li>网络存储<ul>
<li>cinder</li>
<li>cephfs</li>
<li>iscsi</li>
<li>flocker</li>
<li>glusterfs</li>
<li>…</li>
</ul>
</li>
<li>k8s 内部资源卷<ul>
<li>configMap</li>
<li>secret</li>
<li>downwardAPI</li>
</ul>
</li>
<li>persistentVolumeClaim：动态配置的持久存储</li>
</ul>
<h2 id="6-2-通过卷在容器之间共享数据-165"><a href="#6-2-通过卷在容器之间共享数据-165" class="headerlink" title="6.2 通过卷在容器之间共享数据 165"></a>6.2 通过卷在容器之间共享数据 165</h2><h3 id="6-2-1-使用-emptyDir-卷-165"><a href="#6-2-1-使用-emptyDir-卷-165" class="headerlink" title="6.2.1 使用 emptyDir 卷 165"></a>6.2.1 使用 emptyDir 卷 165</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: fortune</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: luksa&#x2F;fortune</span><br><span class="line">    name: html-generator</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: html # 名为html的卷挂载在html-generator容器的&#x2F;var&#x2F;htdocs中</span><br><span class="line">      mountPath: &#x2F;var&#x2F;htdocs</span><br><span class="line">  - image: nginx:alpine</span><br><span class="line">    name: web-server</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: html # 名为html的卷挂载在web-server容器的&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html中</span><br><span class="line">      mountPath: &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br><span class="line">      readOnly: true # 设为只读</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">      protocol: TCP</span><br><span class="line">  volumes:</span><br><span class="line">  - name: html # 一个名为html的单独emptyDir卷，挂载在上面的两个容器中</span><br><span class="line">    emptyDir: &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>可以指定用于emptyDir的介质。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  - name: html</span><br><span class="line">    emptyDir:</span><br><span class="line">      medium: Memory # emptyDir的文件将会存储在内存中</span><br></pre></td></tr></table></figure>

<h3 id="6-2-2-使用-Git-仓库作为存储卷-168"><a href="#6-2-2-使用-Git-仓库作为存储卷-168" class="headerlink" title="6.2.2 使用 Git 仓库作为存储卷 168"></a>6.2.2 使用 Git 仓库作为存储卷 168</h3><p>将拉取的git repo作为文件系统，可以方便的读取到git的内容。<br>缺点是，在创建gitRepo卷后，它并不能和对应repo保持同步。<br>可以使用sider容器进行「git sync」。</p>
<p>如果想要将私有的Git repo克隆到容器中，则应该使用gitsync sidecar或类似的方法，而不是使用 gitRepo卷。</p>
<img width="500" src="/images/Kubernetes In Action阅读笔记/21.png">

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: gitrepo-volume-pod</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: nginx:alpine</span><br><span class="line">    name: web-server</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: html</span><br><span class="line">      mountPath: &#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html</span><br><span class="line">      readOnly: true</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 80</span><br><span class="line">      protocol: TCP</span><br><span class="line">  volumes:</span><br><span class="line">  - name: html</span><br><span class="line">    gitRepo: # gitRepo卷</span><br><span class="line">      repository: https:&#x2F;&#x2F;github.com&#x2F;luksa&#x2F;kubia-website-example.git</span><br><span class="line">      revision: master</span><br><span class="line">      directory: . # 将repo克隆到卷的根目录</span><br></pre></td></tr></table></figure>

<h2 id="6-3-访问工作节点文件系统上的文件-171"><a href="#6-3-访问工作节点文件系统上的文件-171" class="headerlink" title="6.3 访问工作节点文件系统上的文件 171"></a>6.3 访问工作节点文件系统上的文件 171</h2><h3 id="6-3-1-介绍-hostPath-卷-171"><a href="#6-3-1-介绍-hostPath-卷-171" class="headerlink" title="6.3.1 介绍 hostPath 卷 171"></a>6.3.1 介绍 hostPath 卷 171</h3><p>hostPath卷指向节点文件系统上的特定文件或目录。</p>
<img width="500" src="/images/Kubernetes In Action阅读笔记/22.png">

<h3 id="6-3-2-检查使用-hostPath-卷的系统-pod-172"><a href="#6-3-2-检查使用-hostPath-卷的系统-pod-172" class="headerlink" title="6.3.2 检查使用 hostPath 卷的系统 pod 172"></a>6.3.2 检查使用 hostPath 卷的系统 pod 172</h3><p>仅当需要在节点上读取或写入系统文件时才使用hostPath，不能用来持久化跨pod的数据。</p>
<h2 id="6-4-使用持久化存储-173"><a href="#6-4-使用持久化存储-173" class="headerlink" title="6.4 使用持久化存储 173"></a>6.4 使用持久化存储 173</h2><h3 id="6-4-1-使用-GCE-持久磁盘作为-pod-存储卷-174"><a href="#6-4-1-使用-GCE-持久磁盘作为-pod-存储卷-174" class="headerlink" title="6.4.1 使用 GCE 持久磁盘作为 pod 存储卷 174"></a>6.4.1 使用 GCE 持久磁盘作为 pod 存储卷 174</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mongodb </span><br><span class="line">spec:</span><br><span class="line">  volumes:</span><br><span class="line">  - name: mongodb-data</span><br><span class="line">    gcePersistentDisk: # 卷类型是GCE持久磁盘</span><br><span class="line">      pdName: mongodb</span><br><span class="line">      fsType: ext4 # 文件系统类型是EXT4</span><br><span class="line">  containers:</span><br><span class="line">  - image: mongo</span><br><span class="line">    name: mongodb</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: mongodb-data</span><br><span class="line">      mountPath: &#x2F;data&#x2F;db # MongoDB数据存放的路径</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 27017</span><br><span class="line">      protocol: TCP</span><br></pre></td></tr></table></figure>

<img width="600" src="/images/Kubernetes In Action阅读笔记/23.png">

<h3 id="6-4-2-通过底层持久化存储使用其他类型的卷-177"><a href="#6-4-2-通过底层持久化存储使用其他类型的卷-177" class="headerlink" title="6.4.2 通过底层持久化存储使用其他类型的卷 177"></a>6.4.2 通过底层持久化存储使用其他类型的卷 177</h3><ul>
<li>使用AWS弹性块存储卷</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">spec:</span><br><span class="line">  volumes:</span><br><span class="line">  - name: mongodb-data</span><br><span class="line">    awsElasticBlockStore:</span><br><span class="line">      volumeID: my-volume</span><br><span class="line">      fsType: ext4</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<ul>
<li>使用NFS卷</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">spec:</span><br><span class="line">  volumes:</span><br><span class="line">  - name: mongodb-data</span><br><span class="line">    nfs:</span><br><span class="line">      server: 1.2.3.4</span><br><span class="line">      path: &#x2F;some&#x2F;path</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h2 id="6-5-从底层存储技术解耦-pod-179"><a href="#6-5-从底层存储技术解耦-pod-179" class="headerlink" title="6.5 从底层存储技术解耦 pod 179"></a>6.5 从底层存储技术解耦 pod 179</h2><p><a href="https://kubernetes.io/docs/concepts/storage/persistent-volumes/" target="_blank" rel="noopener">persistent-volume的官方文档</a></p>
<p>将这种涉及基础设施类型的信息塞到一个pod设置中，意味着pod设置与特定的k8s集群有很大耦合度。这就不能在另一个pod中使用相同的设置了。所以使用这样的卷并不是在pod中附加持久化存储的最佳实践。</p>
<p>理想的情况是，在k8s上部署应用程序的开发人员不需要知道底层使用的是哪种存储技术，同理他们也不需要了解应该使用哪些类型的物理服务器来运行pod，与基础设施相关的交互是集群管理员独有的控制领域。</p>
<h3 id="6-5-1-介绍持久卷和持久卷声明-179"><a href="#6-5-1-介绍持久卷和持久卷声明-179" class="headerlink" title="6.5.1 介绍持久卷和持久卷声明 179"></a>6.5.1 介绍持久卷和持久卷声明 179</h3><p>系统管理员首先准备好磁盘资源，然后创建全局的持久卷(Persistent Volume)。</p>
<p>然后用户通过创建持久卷声明(PersistentVolumeClaim，简称PVC)清单，指定所需要的最低容量要求和访问模式，然后用户将持久卷声明清单提交给k8s的API服务器，k8s将找到可匹配的持久卷并将其绑定到持久卷声明。</p>
<p>持久卷声明可以当作pod中的一个卷来使用，其他用户不能使用相同的持久卷，除非先通过删除持久卷声明绑定来释放。</p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/24.png">

<h3 id="6-5-2-创建持久卷-180"><a href="#6-5-2-创建持久卷-180" class="headerlink" title="6.5.2 创建持久卷 180"></a>6.5.2 创建持久卷 180</h3><p>创建持久卷</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolume</span><br><span class="line">metadata:</span><br><span class="line">  name: mongodb-pv</span><br><span class="line">spec:</span><br><span class="line">  capacity: # 定义PersistentVolume的大小</span><br><span class="line">    storage: 1Gi</span><br><span class="line">  accessModes: # 可以被单个客户端挂载为读写模式或被多个客户端挂载为只读模式</span><br><span class="line">    - ReadWriteOnce</span><br><span class="line">    - ReadOnlyMany</span><br><span class="line">  persistentVolumeReclaimPolicy: Retain # 当声明被释放后，PersistentVolume将会被保留</span><br><span class="line">  gcePersistentDisk: # PersistentVolume指定支持之前创建的GCE持久磁盘</span><br><span class="line">    pdName: mongodb</span><br><span class="line">    fsType: ext4</span><br></pre></td></tr></table></figure>

<p>在pod卷中引用GCE PD</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spec:</span><br><span class="line">  volumes:</span><br><span class="line">  - name: mongodb-data</span><br><span class="line">    gcePersistentDisk:</span><br><span class="line">      pdName: mongodb</span><br><span class="line">      fsType: ext4</span><br></pre></td></tr></table></figure>

<p>在创建持久卷时，管理员需要告诉k8s其对应的容量需求，以及它是否可以由单个节点或多个节点同时读取或写入。管理员还需要告诉k8s如何处理PersistentVolume（当持久卷声明的绑定被删除时）。最后，无疑也很重要的事情是，管理员需要指定持久卷支持的实际存储类型、位置和其他属性。</p>
<p>持久卷不属于任何命名空间，它跟节点一样是集群层面的资源。</p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/25.png">

<h3 id="6-5-3-通过创建持久卷声明来获取持久卷-182"><a href="#6-5-3-通过创建持久卷声明来获取持久卷-182" class="headerlink" title="6.5.3 通过创建持久卷声明来获取持久卷 182"></a>6.5.3 通过创建持久卷声明来获取持久卷 182</h3><p>创建持久卷声明</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: mongodb-pvc # 声明的名称，将声明当做pod的卷使用时需要用到</span><br><span class="line">spec:</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 1Gi # 申请1GiB的存储空间</span><br><span class="line">  accessModes:</span><br><span class="line">  - ReadWriteOnce # 允许单个客户端访问(同时支持读取和写入操作)</span><br><span class="line">  storageClassName: &quot;&quot; # 将空字符串指定为存储类名可确保PVC绑定到预先配置的PV，而不是动态配置新的PV</span><br></pre></td></tr></table></figure>

<p>当创建好持久卷声明，k8s就会找到适当的持久卷并将其绑定到声明，持久卷的容量必须足够大以满足声明的需求，并且卷的访问模式必须包含声明中指定的访问模式。</p>
<p>访问模式：</p>
<ul>
<li>PWO： ReadWriteOnce，仅允许单个节点挂载读写；</li>
<li>ROX： ReadOnlyMany，允许多个节点挂载读；</li>
<li>RWX： ReadWriteMany，允许多个节点挂载读写。</li>
</ul>
<blockquote>
<p>accessModes设置的是同时使用卷的工作节点的数量，而非pod的数量。</p>
</blockquote>
<h3 id="6-5-4-在-pod-中使用持久卷声明-184"><a href="#6-5-4-在-pod-中使用持久卷声明-184" class="headerlink" title="6.5.4 在 pod 中使用持久卷声明 184"></a>6.5.4 在 pod 中使用持久卷声明 184</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mongodb </span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: mongo</span><br><span class="line">    name: mongodb</span><br><span class="line">    volumeMounts:</span><br><span class="line">    - name: mongodb-data</span><br><span class="line">      mountPath: &#x2F;data&#x2F;db</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 27017</span><br><span class="line">      protocol: TCP</span><br><span class="line">  volumes:</span><br><span class="line">  - name: mongodb-data</span><br><span class="line">    persistentVolumeClaim: # 在pod卷中通过名称引用持久卷声明</span><br><span class="line">      claimName: mongodb-pvc</span><br></pre></td></tr></table></figure>

<h3 id="6-5-5-了解使用持久卷和持久卷声明的好处-185"><a href="#6-5-5-了解使用持久卷和持久卷声明的好处-185" class="headerlink" title="6.5.5 了解使用持久卷和持久卷声明的好处 185"></a>6.5.5 了解使用持久卷和持久卷声明的好处 185</h3><img width="600" src="/images/Kubernetes In Action阅读笔记/26.png">

<h3 id="6-5-6-回收持久卷-186"><a href="#6-5-6-回收持久卷-186" class="headerlink" title="6.5.6 回收持久卷 186"></a>6.5.6 回收持久卷 186</h3><p>通过将persistentVolumeReclaimPolicy设置为Retain从而通知到k8s，希望在创建持久卷后将其持久化，让k8s可以在持久卷从持久卷声明中释放后仍然能保留它的卷和数据内容。手动回收持久卷并使其恢复可用的唯一方法是删除和重新创建持久卷资源。</p>
<p>存在两种其他可行的回收策略：Recycle和Delete。第一种删除卷的内容并使卷可用于再次声明，通过这种方式，持久卷可以被不同的持久卷声明和pod反复使用。</p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/27.png">

<h2 id="6-6-持久卷的动态卷配置-187"><a href="#6-6-持久卷的动态卷配置-187" class="headerlink" title="6.6 持久卷的动态卷配置 187"></a>6.6 持久卷的动态卷配置 187</h2><p><a href="https://kubernetes.io/docs/concepts/storage/storage-classes/" target="_blank" rel="noopener">storage-class的官方文档</a></p>
<h3 id="6-6-1-通过-StorageClass-资源定义可用存储类型-188"><a href="#6-6-1-通过-StorageClass-资源定义可用存储类型-188" class="headerlink" title="6.6.1 通过 StorageClass 资源定义可用存储类型 188"></a>6.6.1 通过 StorageClass 资源定义可用存储类型 188</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: storage.k8s.io&#x2F;v1</span><br><span class="line">kind: StorageClass</span><br><span class="line">metadata:</span><br><span class="line">  name: fast</span><br><span class="line">provisioner: kubernetes.io&#x2F;gce-pd # 用于配置持久卷的卷插件</span><br><span class="line">parameters:</span><br><span class="line">  type: pd-ssd</span><br><span class="line">  zone: europe-westl-b</span><br></pre></td></tr></table></figure>

<h3 id="6-6-2-请求持久卷声明中的存储类-188"><a href="#6-6-2-请求持久卷声明中的存储类-188" class="headerlink" title="6.6.2 请求持久卷声明中的存储类 188"></a>6.6.2 请求持久卷声明中的存储类 188</h3><p>StorageClass资源指定当久卷声明请求此StorageClass时应使用哪个置备程序来提供持久卷。StorageClass定义中定义的参数将传递给置备程序，并具体到每个供应器插件。</p>
<p>简单地说，管理员可以手动通过置备程序创建PV，或者直接创建对应的StorageClass，然后用户创建PVC时，会自动根据StorageClass的设置调用置备程序创建出可供使用的PV。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: mongodb-pvc </span><br><span class="line">spec:</span><br><span class="line">  storageClassName: fast # 该PVC请求自定义存储类</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 100Mi</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br></pre></td></tr></table></figure>

<p>StorageClasses的好处在于，声明是通过名称引用它们的。因此，只要StorageClass名称在所有这些名称中相同，PVC定义便可跨不同集群移植。</p>
<h3 id="6-6-3-不指定存储类的动态配置-190"><a href="#6-6-3-不指定存储类的动态配置-190" class="headerlink" title="6.6.3 不指定存储类的动态配置 190"></a>6.6.3 不指定存储类的动态配置 190</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: PersistentVolumeClaim</span><br><span class="line">metadata:</span><br><span class="line">  name: mongodb-pvc2 </span><br><span class="line">spec:</span><br><span class="line">  resources:</span><br><span class="line">    requests:</span><br><span class="line">      storage: 100Mi</span><br><span class="line">  accessModes:</span><br><span class="line">    - ReadWriteOnce</span><br></pre></td></tr></table></figure>

<img width="700" src="/images/Kubernetes In Action阅读笔记/28.png">

<h2 id="6-7-本章的k8s命令-193"><a href="#6-7-本章的k8s命令-193" class="headerlink" title="6.7 本章的k8s命令 193"></a>6.7 本章的k8s命令 193</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">########## PersistentVolume ##########  </span><br><span class="line"></span><br><span class="line"># 列出所有的PersistentVolume</span><br><span class="line">$ kubectl get pv</span><br><span class="line"></span><br><span class="line">########## PersistentVolumeClaim ##########  </span><br><span class="line"></span><br><span class="line"># 列出所有的PersistentVolumeClaim</span><br><span class="line">$ kubectl get pvc</span><br><span class="line"></span><br><span class="line">########## StorageClass ##########  </span><br><span class="line"></span><br><span class="line"># 列出所有的StorageClass</span><br><span class="line">$ kubectl get sc</span><br><span class="line"></span><br><span class="line"># 查看默认存储类</span><br><span class="line">$ kubectl get sc standard -o yaml</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="Pearl 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Pearl 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Pearl
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://pearlzju.github.io/2021/06/13/%E3%80%8AKubernetes%20In%20Action%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%B8%80)/" title="《Kubernetes In Action》阅读笔记(一)">https://pearlzju.github.io/2021/06/13/%E3%80%8AKubernetes%20In%20Action%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%B8%80)/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Kubernetes/" rel="tag"># Kubernetes</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/06/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%20IO%E6%A8%A1%E5%9E%8B(%E4%B8%80)/" rel="next" title="深入理解Linux IO模型(一)">
                <i class="fa fa-chevron-left"></i> 深入理解Linux IO模型(一)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/06/16/%E3%80%8AKubernetes%20In%20Action%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0(%E4%BA%8C)/" rel="prev" title="《Kubernetes In Action》阅读笔记(二)">
                《Kubernetes In Action》阅读笔记(二) <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/face.jpeg"
                alt="Pearl" />
            
              <p class="site-author-name" itemprop="name">Pearl</p>
              <p class="site-description motion-element" itemprop="description">爱自己是终身浪漫的开始</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">7</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Pearlzju" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:shanglin@zju.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/LINZJU" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.douban.com/people/104033946" target="_blank" title="豆瓣">
                      
                        <i class="fa fa-fw fa-globe"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-Kubernetes-介绍-1"><span class="nav-number">1.</span> <span class="nav-text">1 Kubernetes 介绍 1</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-Kubernetes-系统的需求-2"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 Kubernetes 系统的需求 2</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-1-从单体应用到微服务-2"><span class="nav-number">1.1.1.</span> <span class="nav-text">1.1.1 从单体应用到微服务 2</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-2-为应用程序提供一个一致的环境-5"><span class="nav-number">1.1.2.</span> <span class="nav-text">1.1.2 为应用程序提供一个一致的环境 5</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-3-迈向持续交付-：DevOps-和无运维-6"><span class="nav-number">1.1.3.</span> <span class="nav-text">1.1.3 迈向持续交付 ：DevOps 和无运维 6</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-介绍容器技术-7"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 介绍容器技术 7</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-什么是容器-7"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1 什么是容器 7</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-Docker-容器平台介绍-11"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2 Docker 容器平台介绍 11</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-3-rkt——一个-Docker-的替代方案-14"><span class="nav-number">1.2.3.</span> <span class="nav-text">1.2.3 rkt——一个 Docker 的替代方案 14</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-Kubernetes-介绍-15"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 Kubernetes 介绍 15</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-1-初衷-15"><span class="nav-number">1.3.1.</span> <span class="nav-text">1.3.1 初衷 15</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-2-深入浅出地了解-Kubernetes-15"><span class="nav-number">1.3.2.</span> <span class="nav-text">1.3.2 深入浅出地了解 Kubernetes 15</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-3-Kubernetes-集群架构-17"><span class="nav-number">1.3.3.</span> <span class="nav-text">1.3.3 Kubernetes 集群架构 17</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-4-在-Kubernetes-中运行应用-18"><span class="nav-number">1.3.4.</span> <span class="nav-text">1.3.4 在 Kubernetes 中运行应用 18</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-5-使用-Kubernetes-的好处-20"><span class="nav-number">1.3.5.</span> <span class="nav-text">1.3.5 使用 Kubernetes 的好处 20</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#2-开始使用-Kubernetes-和-Docker-23"><span class="nav-number">2.</span> <span class="nav-text">2 开始使用 Kubernetes 和 Docker 23</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-创建、运行及共享容器镜像-23"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 创建、运行及共享容器镜像 23</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-配置-Kubernetes-集群-34"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 配置 Kubernetes 集群 34</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-在-Kubernetes-上运行第一个应用-40"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 在 Kubernetes 上运行第一个应用 40</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-1-部署-Node-js-应用-40"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1 部署 Node.js 应用 40</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-2-访问-Web-应用-43"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2 访问 Web 应用 43</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-3-系统的逻辑部分-45"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3.3 系统的逻辑部分 45</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-4-水平伸缩应用-46"><span class="nav-number">2.3.4.</span> <span class="nav-text">2.3.4 水平伸缩应用 46</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-5-查看应用运行在哪个节点上-49"><span class="nav-number">2.3.5.</span> <span class="nav-text">2.3.5 查看应用运行在哪个节点上 49</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-6-介绍-Kubernetes-dashboard-50"><span class="nav-number">2.3.6.</span> <span class="nav-text">2.3.6 介绍 Kubernetes dashboard 50</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-本章的k8s命令"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 本章的k8s命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#3-pod-：运行于-Kubernetes-中的容器-53"><span class="nav-number">3.</span> <span class="nav-text">3 pod ：运行于 Kubernetes 中的容器 53</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-介绍-pod-53"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 介绍 pod 53</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-为何需要-pod-54"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1 为何需要 pod 54</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-了解-pod-55"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2 了解 pod 55</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-通过-pod-合理管理容器-56"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.1.3 通过 pod 合理管理容器 56</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-以-YAML-或-JSON-描述文件创建-pod-58"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 以 YAML 或 JSON 描述文件创建 pod 58</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-检查现有-pod-的-YAML-描述文件-59"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 检查现有 pod 的 YAML 描述文件 59</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-为-pod-创建一个简单的-YAML-描述文件-61"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2 为 pod 创建一个简单的 YAML 描述文件 61</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-使用-kubectl-create-来创建-pod-63"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.2.3 使用 kubectl create 来创建 pod 63</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-查看应用程序日志-64"><span class="nav-number">3.2.4.</span> <span class="nav-text">3.2.4 查看应用程序日志 64</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-5-向-pod-发送请求-65"><span class="nav-number">3.2.5.</span> <span class="nav-text">3.2.5 向 pod 发送请求 65</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-使用标签组织-pod-66"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 使用标签组织 pod 66</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-介绍标签-66"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1 介绍标签 66</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-创建-pod-时指定标签-67"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2 创建 pod 时指定标签 67</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-修改现有-pod-的标签-68"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3.3 修改现有 pod 的标签 68</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-通过标签选择器列出-pod-子集-69"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 通过标签选择器列出 pod 子集 69</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-1-使用标签选择器列出-pod-69"><span class="nav-number">3.4.1.</span> <span class="nav-text">3.4.1 使用标签选择器列出 pod 69</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-2-在标签选择器中使用多个条件-71"><span class="nav-number">3.4.2.</span> <span class="nav-text">3.4.2 在标签选择器中使用多个条件 71</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-使用标签和选择器来约束-pod-调度-71"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 使用标签和选择器来约束 pod 调度 71</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-使用标签分类工作节点-72"><span class="nav-number">3.5.1.</span> <span class="nav-text">3.5.1 使用标签分类工作节点 72</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-将-pod-调度到特定节点-72"><span class="nav-number">3.5.2.</span> <span class="nav-text">3.5.2 将 pod 调度到特定节点 72</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-3-调度到一个特定节点-73"><span class="nav-number">3.5.3.</span> <span class="nav-text">3.5.3 调度到一个特定节点 73</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-注解-pod-73"><span class="nav-number">3.6.</span> <span class="nav-text">3.6 注解 pod 73</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-1-查找对象的注解-74"><span class="nav-number">3.6.1.</span> <span class="nav-text">3.6.1 查找对象的注解 74</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-6-2-添加和修改注解-74"><span class="nav-number">3.6.2.</span> <span class="nav-text">3.6.2 添加和修改注解 74</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-使用命名空间对资源进行分组-75"><span class="nav-number">3.7.</span> <span class="nav-text">3.7 使用命名空间对资源进行分组 75</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-1-了解对命名空间的需求-75"><span class="nav-number">3.7.1.</span> <span class="nav-text">3.7.1 了解对命名空间的需求 75</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-2-发现其他命名空间及其-pod-75"><span class="nav-number">3.7.2.</span> <span class="nav-text">3.7.2 发现其他命名空间及其 pod 75</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-3-创建一个命名空间-76"><span class="nav-number">3.7.3.</span> <span class="nav-text">3.7.3 创建一个命名空间 76</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-4-管理其他命名空间中的对象-77"><span class="nav-number">3.7.4.</span> <span class="nav-text">3.7.4 管理其他命名空间中的对象 77</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-7-5-命名空间提供的隔离-78"><span class="nav-number">3.7.5.</span> <span class="nav-text">3.7.5 命名空间提供的隔离 78</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-停止和移除-pod-78"><span class="nav-number">3.8.</span> <span class="nav-text">3.8 停止和移除 pod 78</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-1-按名称删除-pod-78"><span class="nav-number">3.8.1.</span> <span class="nav-text">3.8.1 按名称删除 pod 78</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-2-使用标签选择器删除-pod-79"><span class="nav-number">3.8.2.</span> <span class="nav-text">3.8.2 使用标签选择器删除 pod 79</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-3-通过删除整个命名空间来删除-pod-80"><span class="nav-number">3.8.3.</span> <span class="nav-text">3.8.3 通过删除整个命名空间来删除 pod 80</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-4-删除命名空间中的所有-pod，但保留命名空间-80"><span class="nav-number">3.8.4.</span> <span class="nav-text">3.8.4 删除命名空间中的所有 pod，但保留命名空间 80</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-8-5-删除命名空间中的（几乎）所有资源-80"><span class="nav-number">3.8.5.</span> <span class="nav-text">3.8.5 删除命名空间中的（几乎）所有资源 80</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-9-本章的k8s命令"><span class="nav-number">3.9.</span> <span class="nav-text">3.9 本章的k8s命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-副本机制和其他控制器-：部署托管的-pod-83"><span class="nav-number">4.</span> <span class="nav-text">4 副本机制和其他控制器 ：部署托管的 pod 83</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-保持-pod-健康-84"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 保持 pod 健康 84</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-1-介绍存活探针-84"><span class="nav-number">4.1.1.</span> <span class="nav-text">4.1.1 介绍存活探针 84</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-2-创建基于-HTTP-的存活探针-85"><span class="nav-number">4.1.2.</span> <span class="nav-text">4.1.2 创建基于 HTTP 的存活探针 85</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-3-使用存活探针-86"><span class="nav-number">4.1.3.</span> <span class="nav-text">4.1.3 使用存活探针 86</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-4-配置存活探针的附加属性-87"><span class="nav-number">4.1.4.</span> <span class="nav-text">4.1.4 配置存活探针的附加属性 87</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-5-创建有效的存活探针-88"><span class="nav-number">4.1.5.</span> <span class="nav-text">4.1.5 创建有效的存活探针 88</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-了解-ReplicationController-89"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 了解 ReplicationController 89</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-使用-ReplicaSet-而不是-ReplicationController-104"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 使用 ReplicaSet 而不是 ReplicationController 104</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-比较-ReplicaSet-和-ReplicationController-104"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1 比较 ReplicaSet 和 ReplicationController 104</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-定义-ReplicaSet-105"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2 定义 ReplicaSet 105</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-创建和检查-ReplicaSet-106"><span class="nav-number">4.3.3.</span> <span class="nav-text">4.3.3 创建和检查 ReplicaSet 106</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-4-使用-ReplicaSet-的更富表达力的标签选择器-106"><span class="nav-number">4.3.4.</span> <span class="nav-text">4.3.4 使用 ReplicaSet 的更富表达力的标签选择器 106</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-5-ReplicaSet-小结-107"><span class="nav-number">4.3.5.</span> <span class="nav-text">4.3.5 ReplicaSet 小结 107</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-使用-DaemonSet-在每个节点上运行一个-pod-107"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 使用 DaemonSet 在每个节点上运行一个 pod 107</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1-使用-DaemonSet-在每个节点上运行一个-pod-108"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.4.1 使用 DaemonSet 在每个节点上运行一个 pod 108</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2-使用-DaemonSet-只在特定的节点上运行-pod-109"><span class="nav-number">4.4.2.</span> <span class="nav-text">4.4.2 使用 DaemonSet 只在特定的节点上运行 pod 109</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-5-运行执行单个任务的-pod-112"><span class="nav-number">4.5.</span> <span class="nav-text">4.5 运行执行单个任务的 pod 112</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-1-介绍-Job-资源-112"><span class="nav-number">4.5.1.</span> <span class="nav-text">4.5.1 介绍 Job 资源 112</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-2-定义-Job-资源-113"><span class="nav-number">4.5.2.</span> <span class="nav-text">4.5.2 定义 Job 资源 113</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-3-看-Job-运行一个-pod-114"><span class="nav-number">4.5.3.</span> <span class="nav-text">4.5.3 看 Job 运行一个 pod 114</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-4-在-Job-中运行多个-pod-实例-114"><span class="nav-number">4.5.4.</span> <span class="nav-text">4.5.4 在 Job 中运行多个 pod 实例 114</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-5-限制-Job-pod-完成任务的时间-116"><span class="nav-number">4.5.5.</span> <span class="nav-text">4.5.5 限制 Job pod 完成任务的时间 116</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-6-安排-Job-定期运行或在将来运行一次-116"><span class="nav-number">4.6.</span> <span class="nav-text">4.6 安排 Job 定期运行或在将来运行一次 116</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-1-创建一个-CronJob-116"><span class="nav-number">4.6.1.</span> <span class="nav-text">4.6.1 创建一个 CronJob 116</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-2-了解计划任务的运行方式-118"><span class="nav-number">4.6.2.</span> <span class="nav-text">4.6.2 了解计划任务的运行方式 118</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-7-本章的k8s命令-118"><span class="nav-number">4.7.</span> <span class="nav-text">4.7 本章的k8s命令 118</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#5-服务-：让客户端发现-pod-并与之通信-121"><span class="nav-number">5.</span> <span class="nav-text">5 服务 ：让客户端发现 pod 并与之通信 121</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-介绍服务-122"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 介绍服务 122</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-创建服务-123"><span class="nav-number">5.1.1.</span> <span class="nav-text">5.1.1 创建服务 123</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-服务发现-129"><span class="nav-number">5.1.2.</span> <span class="nav-text">5.1.2 服务发现 129</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-连接集群外部的服务-132"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 连接集群外部的服务 132</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-介绍服务-endpoint-133"><span class="nav-number">5.2.1.</span> <span class="nav-text">5.2.1 介绍服务 endpoint 133</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-手动配置服务的-endpoint-133"><span class="nav-number">5.2.2.</span> <span class="nav-text">5.2.2 手动配置服务的 endpoint 133</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-3-为外部服务创建别名-135"><span class="nav-number">5.2.3.</span> <span class="nav-text">5.2.3 为外部服务创建别名 135</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-将服务暴露给外部客户端-136"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 将服务暴露给外部客户端 136</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-使用-NodePort-类型的服务-137"><span class="nav-number">5.3.1.</span> <span class="nav-text">5.3.1 使用 NodePort 类型的服务 137</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-通过负载均衡器将服务暴露出来-140"><span class="nav-number">5.3.2.</span> <span class="nav-text">5.3.2 通过负载均衡器将服务暴露出来 140</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-3-了解外部连接的特性-142"><span class="nav-number">5.3.3.</span> <span class="nav-text">5.3.3 了解外部连接的特性 142</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-通过-Ingress-暴露服务-143"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 通过 Ingress 暴露服务 143</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-1-创建-Ingress-资源-145"><span class="nav-number">5.4.1.</span> <span class="nav-text">5.4.1 创建 Ingress 资源 145</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-2-通过-Ingress-访问服务-146"><span class="nav-number">5.4.2.</span> <span class="nav-text">5.4.2 通过 Ingress 访问服务 146</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-3-通过相同的-Ingress-暴露多个服务-147"><span class="nav-number">5.4.3.</span> <span class="nav-text">5.4.3 通过相同的 Ingress 暴露多个服务 147</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-4-配置-Ingress-处理-TLS-传输-149"><span class="nav-number">5.4.4.</span> <span class="nav-text">5.4.4 配置 Ingress 处理 TLS 传输 149</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-5-pod-就绪后发出信号-150"><span class="nav-number">5.5.</span> <span class="nav-text">5.5 pod 就绪后发出信号 150</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-1-介绍就绪探针-151"><span class="nav-number">5.5.1.</span> <span class="nav-text">5.5.1 介绍就绪探针 151</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-2-向-pod-添加就绪探针-152"><span class="nav-number">5.5.2.</span> <span class="nav-text">5.5.2 向 pod 添加就绪探针 152</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-3-了解就绪探针的实际作用-154"><span class="nav-number">5.5.3.</span> <span class="nav-text">5.5.3 了解就绪探针的实际作用 154</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-6-使用-headless-服务来发现独立的-pod-155"><span class="nav-number">5.6.</span> <span class="nav-text">5.6 使用 headless 服务来发现独立的 pod 155</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-1-创建-headless-服务-156"><span class="nav-number">5.6.1.</span> <span class="nav-text">5.6.1 创建 headless 服务 156</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-2-通过-DNS-发现-pod-156"><span class="nav-number">5.6.2.</span> <span class="nav-text">5.6.2 通过 DNS 发现 pod 156</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-6-3-发现所有的-pod——包括未就绪的-pod-157"><span class="nav-number">5.6.3.</span> <span class="nav-text">5.6.3 发现所有的 pod——包括未就绪的 pod 157</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-7-排除服务故障-158"><span class="nav-number">5.7.</span> <span class="nav-text">5.7 排除服务故障 158</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-8-本章的k8s命令-159"><span class="nav-number">5.8.</span> <span class="nav-text">5.8 本章的k8s命令 159</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#6-卷-：将磁盘挂载到容器-161"><span class="nav-number">6.</span> <span class="nav-text">6 卷 ：将磁盘挂载到容器 161</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-介绍卷-162"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 介绍卷 162</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-卷的应用示例-162"><span class="nav-number">6.1.1.</span> <span class="nav-text">6.1.1 卷的应用示例 162</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-介绍可用的卷类型-164"><span class="nav-number">6.1.2.</span> <span class="nav-text">6.1.2 介绍可用的卷类型 164</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-通过卷在容器之间共享数据-165"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 通过卷在容器之间共享数据 165</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-使用-emptyDir-卷-165"><span class="nav-number">6.2.1.</span> <span class="nav-text">6.2.1 使用 emptyDir 卷 165</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-使用-Git-仓库作为存储卷-168"><span class="nav-number">6.2.2.</span> <span class="nav-text">6.2.2 使用 Git 仓库作为存储卷 168</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-访问工作节点文件系统上的文件-171"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 访问工作节点文件系统上的文件 171</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1-介绍-hostPath-卷-171"><span class="nav-number">6.3.1.</span> <span class="nav-text">6.3.1 介绍 hostPath 卷 171</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-检查使用-hostPath-卷的系统-pod-172"><span class="nav-number">6.3.2.</span> <span class="nav-text">6.3.2 检查使用 hostPath 卷的系统 pod 172</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-4-使用持久化存储-173"><span class="nav-number">6.4.</span> <span class="nav-text">6.4 使用持久化存储 173</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-1-使用-GCE-持久磁盘作为-pod-存储卷-174"><span class="nav-number">6.4.1.</span> <span class="nav-text">6.4.1 使用 GCE 持久磁盘作为 pod 存储卷 174</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-4-2-通过底层持久化存储使用其他类型的卷-177"><span class="nav-number">6.4.2.</span> <span class="nav-text">6.4.2 通过底层持久化存储使用其他类型的卷 177</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-5-从底层存储技术解耦-pod-179"><span class="nav-number">6.5.</span> <span class="nav-text">6.5 从底层存储技术解耦 pod 179</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-1-介绍持久卷和持久卷声明-179"><span class="nav-number">6.5.1.</span> <span class="nav-text">6.5.1 介绍持久卷和持久卷声明 179</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-2-创建持久卷-180"><span class="nav-number">6.5.2.</span> <span class="nav-text">6.5.2 创建持久卷 180</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-3-通过创建持久卷声明来获取持久卷-182"><span class="nav-number">6.5.3.</span> <span class="nav-text">6.5.3 通过创建持久卷声明来获取持久卷 182</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-4-在-pod-中使用持久卷声明-184"><span class="nav-number">6.5.4.</span> <span class="nav-text">6.5.4 在 pod 中使用持久卷声明 184</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-5-了解使用持久卷和持久卷声明的好处-185"><span class="nav-number">6.5.5.</span> <span class="nav-text">6.5.5 了解使用持久卷和持久卷声明的好处 185</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-5-6-回收持久卷-186"><span class="nav-number">6.5.6.</span> <span class="nav-text">6.5.6 回收持久卷 186</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-6-持久卷的动态卷配置-187"><span class="nav-number">6.6.</span> <span class="nav-text">6.6 持久卷的动态卷配置 187</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-1-通过-StorageClass-资源定义可用存储类型-188"><span class="nav-number">6.6.1.</span> <span class="nav-text">6.6.1 通过 StorageClass 资源定义可用存储类型 188</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-2-请求持久卷声明中的存储类-188"><span class="nav-number">6.6.2.</span> <span class="nav-text">6.6.2 请求持久卷声明中的存储类 188</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-6-3-不指定存储类的动态配置-190"><span class="nav-number">6.6.3.</span> <span class="nav-text">6.6.3 不指定存储类的动态配置 190</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-7-本章的k8s命令-193"><span class="nav-number">6.7.</span> <span class="nav-text">6.7 本章的k8s命令 193</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pearl</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'ECUWkqa8FVLG7NN721RUeTXk-gzGzoHsz',
        appKey: 'BEMbJ6wNDs62iTOP3UAxzVle',
        placeholder: '说点什么呢',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("ECUWkqa8FVLG7NN721RUeTXk-gzGzoHsz", "BEMbJ6wNDs62iTOP3UAxzVle");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
