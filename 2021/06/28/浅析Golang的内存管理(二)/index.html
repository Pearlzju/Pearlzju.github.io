<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Golang," />










<meta name="description" content="[TOC]  学习Go的内存管理可以帮助我们编写更高性能的代码。    引言在Go中由runtime来进行内存管理，通过内存分配器分配堆内存，垃圾处理器回收堆上不再使用的对象和内存空间。上一节讲了内存分配，这节讲垃圾回收。 现代编程语言中，垃圾收集有很多种算法，本文只讨论Go的垃圾收集器算法。  彻底理解Go runtime的垃圾回收是比较困难的，本文只是我个人学习过程中的总结，是站在我个人角度上">
<meta property="og:type" content="article">
<meta property="og:title" content="浅析Golang的内存管理(二)">
<meta property="og:url" content="https://pearlzju.github.io/2021/06/28/%E6%B5%85%E6%9E%90Golang%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E4%BA%8C)/index.html">
<meta property="og:site_name" content="Pearl 的个人小站">
<meta property="og:description" content="[TOC]  学习Go的内存管理可以帮助我们编写更高性能的代码。    引言在Go中由runtime来进行内存管理，通过内存分配器分配堆内存，垃圾处理器回收堆上不再使用的对象和内存空间。上一节讲了内存分配，这节讲垃圾回收。 现代编程语言中，垃圾收集有很多种算法，本文只讨论Go的垃圾收集器算法。  彻底理解Go runtime的垃圾回收是比较困难的，本文只是我个人学习过程中的总结，是站在我个人角度上">
<meta property="og:image" content="https://pearlzju.github.io/images/%E6%B5%85%E6%9E%90Golang%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/0.png">
<meta property="og:image" content="https://pearlzju.github.io/images/%E6%B5%85%E6%9E%90Golang%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/8.gif">
<meta property="og:image" content="https://pearlzju.github.io/images/%E6%B5%85%E6%9E%90Golang%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/9.gif">
<meta property="og:image" content="https://pearlzju.github.io/images/%E6%B5%85%E6%9E%90Golang%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/10.png">
<meta property="og:image" content="https://pearlzju.github.io/images/%E6%B5%85%E6%9E%90Golang%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/11.png">
<meta property="article:published_time" content="2021-06-28T10:19:09.449Z">
<meta property="article:modified_time" content="2021-07-02T14:56:37.373Z">
<meta property="article:author" content="Pearl">
<meta property="article:tag" content="Golang">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://pearlzju.github.io/images/%E6%B5%85%E6%9E%90Golang%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/0.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://pearlzju.github.io/2021/06/28/浅析Golang的内存管理(二)/"/>





  <title>浅析Golang的内存管理(二) | Pearl 的个人小站</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e99d362e55bda406e16937db2b48aebc";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Pearl 的个人小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">终身学习者</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pearlzju.github.io/2021/06/28/%E6%B5%85%E6%9E%90Golang%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E4%BA%8C)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Pearl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/face.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pearl 的个人小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">浅析Golang的内存管理(二)</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-28T18:19:09+08:00">
                2021-06-28
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/06/28/%E6%B5%85%E6%9E%90Golang%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E4%BA%8C)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/06/28/%E6%B5%85%E6%9E%90Golang%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E4%BA%8C)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2021/06/28/%E6%B5%85%E6%9E%90Golang%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E4%BA%8C)/" class="leancloud_visitors" data-flag-title="浅析Golang的内存管理(二)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>[TOC]</p>
<blockquote>
<p>学习Go的内存管理可以帮助我们编写更高性能的代码。</p>
</blockquote>
<img width="500" src="/images/浅析Golang的内存管理/0.png">

<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在Go中由<code>runtime</code>来进行内存管理，通过内存分配器分配堆内存，垃圾处理器回收堆上不再使用的对象和内存空间。上一节讲了内存分配，这节讲垃圾回收。</p>
<p>现代编程语言中，垃圾收集有很多种算法，本文只讨论Go的垃圾收集器算法。</p>
<blockquote>
<p>彻底理解Go runtime的垃圾回收是比较困难的，本文只是我个人学习过程中的总结，是站在我个人角度上进行的理解和梳理，深度不够。如果要更全面地学习Go的垃圾回收，推荐阅读本文最后列出的Reference和Go的源码。</p>
</blockquote>
<h1 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>虽然Go的GC(Garbage Collection)和用户goroutine可以并发执行，但是需要一段时间的STW(Stop the world)。当程序占用的内存达到一定阈值时，整个应用程序会暂停。垃圾收集器扫描已经分配的所有对象并回收不再使用的内存空间。</p>
<p>Go的GC的STW(Stop the world)影响程序性能是常听到的说法。因为一旦触发垃圾回收，在启动STW到停止STW的过程中，CPU不执行应用代码，全部用于执行GC代码，追求实时的应用无法接受长时间的STW。</p>
<p>垃圾收集器是Go的<code>runtime</code>改进最努力的部分，针对缩短STW时间做了很多迭代优化，目的都是为了提供程序实时性。</p>
<p><code>src/runtime/mgc.go</code>的开头有这样一段注释。</p>
<blockquote>
<p>The GC runs concurrently with mutator threads, is type accurate (aka precise), allows multiple GC thread to run in parallel. It is a concurrent mark and sweep that uses a write barrier. It is non-generational and non-compacting. Allocation is done using size segregated per P allocation areas to minimize fragmentation while eliminating locks in the common case.</p>
</blockquote>
<p>Go的GC是并发标记清理、使用写屏障、非紧缩、非分代的。</p>
<p>并发标记和用户代码同时执行让程序处于不稳定状态。用户代码在标记过程中，可能会修改已经扫描标记过的区域，或在标记过程中分配新对象。</p>
<p>垃圾回收最大的问题是，究竟什么时候启动垃圾回收？过早会浪费CPU资源，影响用户程序的性能；太晚会导致内存堆积。所以垃圾回收核心需要解决的问题有两个：一是抑制堆内存增长；二是充分利用CPU资源。</p>
<h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>早期的Go用的是标记清除(mark-sweep)算法。</p>
<h3 id="GC流程"><a href="#GC流程" class="headerlink" title="GC流程"></a>GC流程</h3><p>标记清除算法分成标记和清除两个阶段。</p>
<ol>
<li>标记阶段：从根对象出发，遍历并标记所有可达的对象，作上标记。</li>
<li>清除阶段：清除未被标记的对象。</li>
</ol>
<img width="300" src="/images/浅析Golang的内存管理/8.gif">

<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol>
<li>标记需要遍历整个heap。</li>
<li>清除会产生heap碎片。</li>
<li>标记前启动STW，清除后停止STW。在该过程中，应用程序都是暂停的，程序卡顿影响性能。</li>
</ol>
<h2 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h2><p>为了缩短标记清除算法的STW时间，用三色标记算法优化。</p>
<p>三色标记算法将程序中的对象分为黑、灰、白三类。新创建的对象，默认都是白色。当完成全部扫描和标记后，剩余的非黑即白，黑色代表活跃对象，白色代表待回收对象，清理操作只需将白色对象的内存回收即可。</p>
<h3 id="GC流程-1"><a href="#GC流程-1" class="headerlink" title="GC流程"></a>GC流程</h3><ol>
<li>从根节点遍历所有对象一次，标记为灰色，放入灰色标记表。</li>
<li>遍历灰色标记表，将可达的对象，标记为灰色，放入灰色标记表。已经遍历过的灰色对象，标记为黑色，放入黑色标记表。</li>
<li>重复上一步，直到灰色标记表为空。</li>
<li>回收最后剩下的白色对象。</li>
</ol>
<img width="300" src="/images/浅析Golang的内存管理/9.gif">

<h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>整个GC过程，都需要STW。</p>
<p>如果不使用STW，GC中途创建或删除对象引用，下面两种情况一旦同时满足，就会导致对象被错误回收，这是致命的内存管理故障。</p>
<ol>
<li>如果黑色对象引用白色对象。因为黑色对象不会再被重复扫描，白色对象以及下游的对象会被GC清除。</li>
<li>如果灰色对象引用白色对象，但是引用被清除。白色对象以及下游的对象会被GC清除。</li>
</ol>
<p>如何在保证对象不丢失情况下，减少STW时间，提高GC效率？——只要破坏其中一个条件，这个问题就被解决。</p>
<h3 id="强-弱三色不变式"><a href="#强-弱三色不变式" class="headerlink" title="强-弱三色不变式"></a>强-弱三色不变式</h3><p>提出强-弱三色不变式来破坏上面两种三色标记算法不能接受的情况。<br>只要满足下面两种不变式的任意一种，对象就不会被错误清理。</p>
<h4 id="强三色不变式"><a href="#强三色不变式" class="headerlink" title="强三色不变式"></a>强三色不变式</h4><p>不允许黑色对象引用白色对象。—— 破坏了上述三色标记算法的缺点1。</p>
<h4 id="弱三色不变式"><a href="#弱三色不变式" class="headerlink" title="弱三色不变式"></a>弱三色不变式</h4><p>黑色对象可以引用白色对象，但是白色对象必须被灰色对象直接或间接(多级可达)引用。—— 破坏了上述三色标记算法的缺点2。</p>
<h2 id="三色标记算法-屏障机制"><a href="#三色标记算法-屏障机制" class="headerlink" title="三色标记算法+屏障机制"></a>三色标记算法+屏障机制</h2><p>何为屏障？我理解是一种hook机制，在GC过程中，某些条件（并发增加/修改/删除对象）满足的时候触发回调，以满足强三色不变式或弱三色不变式，从而保证三色标记算法的正确。</p>
<p>有两种屏障机制，来保证三色标记算法的正确。</p>
<ul>
<li>插入屏障机制：对象被引用时，触发的机制。</li>
<li>删除屏障机制：对象被删除时，触发的机制。</li>
</ul>
<h3 id="插入屏障机制"><a href="#插入屏障机制" class="headerlink" title="插入屏障机制"></a>插入屏障机制</h3><p>当A对象新增引用B对象时，将B对象标记为灰色。——满足强三色不变式。</p>
<p>因为栈内存操作频繁，出于性能考虑，该策略只在堆内存的对象使用。即只在堆对象触发插入屏障机制。</p>
<p>对于栈内存的对象，当A对象新增引用B对象时，还是将B对象标记为白色。但是在GC回收白色对象之前，重新开启STW(防止插入)，扫描一次栈空间。</p>
<p>所以缺点是：在GC结束时需要STW来重新扫描栈。</p>
<h3 id="删除屏障机制"><a href="#删除屏障机制" class="headerlink" title="删除屏障机制"></a>删除屏障机制</h3><p>当白色对象被删除引用时，将它标记为灰色。——满足弱三色不变式。</p>
<p>在栈内存和堆内存均触发删除屏障机制。</p>
<p>这个机制的目的是，当白色对象被删除引用时，如果有黑色对象引用白色对象，白色对象不会被错误回收。但如果白色对象真的被删除引用，在下一轮才会被清理。</p>
<p>所以缺点是：回收精度低。一个对象即使被真的删除了，也只能到下一轮被清理。</p>
<h3 id="混合写屏障机制"><a href="#混合写屏障机制" class="headerlink" title="混合写屏障机制"></a>混合写屏障机制</h3><p>为了避免重新扫描栈，进一步减少STW时间，在插入屏障机制和删除屏障机制的基础上，结合了优点，规避了缺点，引入混合写屏障机制。混合写屏障机制在GC期间通过监视内存中对象的修改，重新标色，来保障标记和用户代码并发执行。</p>
<p>只有堆对象触发混合写屏障机制。</p>
<p>具体规则是：</p>
<ol>
<li>GC开始时，栈上从根节点开始扫描，将全部可达对象都标记为黑色。（避免GC结束时STW重新扫描栈，因为第一轮的可达对象始终是黑色的，而那些GC操作过程中由于并发操作导致的需要被清除的对象，在下一轮GC开始时不再被标记为黑色，所以在下一轮可以被清除。）</li>
<li>GC期间，创建在栈上的新对象，标记为黑色。</li>
<li>GC期间，被添加的对象，标记为灰色。（满足强三色不变式）</li>
<li>GC期间，被删除的对象，标记为灰色。（满足弱三色不变式）</li>
</ol>
<blockquote>
<p>三色标记算法+混合写屏障机制是目前Go runtime使用的垃圾回收策略。</p>
</blockquote>
<h2 id="何时触发GC"><a href="#何时触发GC" class="headerlink" title="何时触发GC"></a>何时触发GC</h2><p>GC的触发条件有两种方式：手动触发和系统触发。</p>
<ul>
<li><p>手动触发：通过应用程序调用<code>runtime.GC()</code>来触发检查调用GC。</p>
</li>
<li><p>系统触发：<code>runtime</code>自行维护，有两个地方会定时检查和GC。</p>
</li>
</ul>
<ol>
<li>在分配内存时，在<code>mallocgc</code>函数里，会检查调用GC。</li>
<li>后台监控线程sysmon定时会检查调用GC。</li>
</ol>
<h3 id="手动触发"><a href="#手动触发" class="headerlink" title="手动触发"></a>手动触发</h3><p>应用程序主动调用<code>GC</code>函数，会阻塞当前运行的应用代码，直到GC完成。</p>
<p>函数位于<code>src\runtime\malloc.go</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">GC</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 获取GC的循环次数</span></span><br><span class="line">    n := atomic.Load(&amp;work.cycles)</span><br><span class="line">    <span class="comment">// 等待上一个循环的标记终止、标记和清除终止阶段完成</span></span><br><span class="line">    gcWaitOnMark(n)</span><br><span class="line">    <span class="comment">// 触发新一轮的GC</span></span><br><span class="line">    gcStart(gcTrigger&#123;kind: gcTriggerCycle, n: n + <span class="number">1</span>&#125;)</span><br><span class="line">    <span class="comment">// 等待当前这轮的循环的标记终止、标记和清除终止阶段完成</span></span><br><span class="line">    gcWaitOnMark(n + <span class="number">1</span>) </span><br><span class="line">    <span class="comment">// 等待清理全部待处理的内存管理单元</span></span><br><span class="line">    <span class="keyword">for</span> atomic.Load(&amp;work.cycles) == n+<span class="number">1</span> &amp;&amp; sweepone() != ^<span class="keyword">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        sweep.nbgsweep++</span><br><span class="line">        <span class="comment">// 主动让出P</span></span><br><span class="line">        Gosched()</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> atomic.Load(&amp;work.cycles) == n+<span class="number">1</span> &amp;&amp; atomic.Load(&amp;mheap_.sweepers) != <span class="number">0</span> &#123;</span><br><span class="line">        Gosched()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mp := acquirem()</span><br><span class="line">    cycle := atomic.Load(&amp;work.cycles)</span><br><span class="line">    <span class="keyword">if</span> cycle == n+<span class="number">1</span> || (gcphase == _GCmark &amp;&amp; cycle == n+<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 完成本轮垃圾收集清理后，将该阶段的堆内存状态快照发布出来(heap profile)</span></span><br><span class="line">        mProf_PostSweep()</span><br><span class="line">    &#125;</span><br><span class="line">    releasem(mp)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，开始执行GC的是<code>gcStart()</code>函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gcStart</span><span class="params">(trigger gcTrigger)</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 检查是否满足垃圾收集条件</span></span><br><span class="line">    <span class="comment">// 并清理已经被标记的内存单元</span></span><br><span class="line">    <span class="keyword">for</span> trigger.test() &amp;&amp; sweepone() != ^<span class="keyword">uintptr</span>(<span class="number">0</span>) &#123;</span><br><span class="line">        sweep.nbgsweep++</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 获取全局的startSema信号量(加锁)</span></span><br><span class="line">    semacquire(&amp;work.startSema) </span><br><span class="line">    <span class="comment">// 再次检查是否满足垃圾收集条件</span></span><br><span class="line">    <span class="keyword">if</span> !trigger.test() &#123;</span><br><span class="line">        semrelease(&amp;work.startSema)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查是不是手动调用了runtime.GC</span></span><br><span class="line">    work.userForced = trigger.kind == gcTriggerCycle </span><br><span class="line"></span><br><span class="line">    semacquire(&amp;gcsema)</span><br><span class="line">    semacquire(&amp;worldsema) </span><br><span class="line">    <span class="comment">// 启动后台标记任务</span></span><br><span class="line">    gcBgMarkStartWorkers()</span><br><span class="line">    <span class="comment">// 重置标记相关的状态</span></span><br><span class="line">    systemstack(gcResetMarkState)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对work结构体做初始化工作，设置垃圾收集需要的goroutine数量</span></span><br><span class="line">    work.stwprocs, work.maxprocs = gomaxprocs, gomaxprocs</span><br><span class="line">    <span class="keyword">if</span> work.stwprocs &gt; ncpu &#123; </span><br><span class="line">        work.stwprocs = ncpu</span><br><span class="line">    &#125; </span><br><span class="line">    work.heap0 = atomic.Load64(&amp;memstats.heap_live)</span><br><span class="line">    work.pauseNS = <span class="number">0</span></span><br><span class="line">    work.mode = mode </span><br><span class="line">    <span class="comment">// 记录开始时间</span></span><br><span class="line">    now := nanotime()</span><br><span class="line">    work.tSweepTerm = now</span><br><span class="line">    work.pauseStart = now</span><br><span class="line">    <span class="comment">// 暂停程序STW</span></span><br><span class="line">    systemstack(stopTheWorldWithSema) </span><br><span class="line">    <span class="comment">// 在并发标记前，确保清理结束</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        finishsweep_m()</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 清理sched.sudogcache以及sync.Pools</span></span><br><span class="line">    clearpools()</span><br><span class="line">    <span class="comment">// GC次数+1</span></span><br><span class="line">    work.cycles++</span><br><span class="line">    <span class="comment">// 在开始GC之前清理控制器的状态，标记新一轮GC已开始</span></span><br><span class="line">    gcController.startCycle()</span><br><span class="line">    work.heapGoal = memstats.next_gc </span><br><span class="line">    <span class="comment">// 设置全局变量中的GC状态为_GCmark，然后启用写屏障</span></span><br><span class="line">    setGCPhase(_GCmark)</span><br><span class="line">    <span class="comment">// 初始化后台扫描需要的状态</span></span><br><span class="line">    gcBgMarkPrepare()</span><br><span class="line">    <span class="comment">// 扫描栈上、全局变量等根对象并将它们加入队列</span></span><br><span class="line">    gcMarkRootPrepare() </span><br><span class="line">    <span class="comment">// 标记所有tiny alloc内存块</span></span><br><span class="line">    gcMarkTinyAllocs() </span><br><span class="line">    <span class="comment">// 启用mutator assists(协助线程)</span></span><br><span class="line">    atomic.Store(&amp;gcBlackenEnabled, <span class="number">1</span>)</span><br><span class="line">    <span class="comment">// 记录标记开始的时间</span></span><br><span class="line">    gcController.markStartTime = now</span><br><span class="line">    mp = acquirem()</span><br><span class="line">    <span class="comment">// 启动程序，后台任务也会开始标记堆中的对象</span></span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        now = startTheWorldWithSema(trace.enabled)</span><br><span class="line">        <span class="comment">// 记录停止了多久, 和标记阶段开始的时间</span></span><br><span class="line">        work.pauseNS += now - work.pauseStart</span><br><span class="line">        work.tMark = now</span><br><span class="line">    &#125;) </span><br><span class="line">    semrelease(&amp;worldsema)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图所示，显示了<code>gcStart</code>过程中状态变化，以及STW停顿的时间段，写屏障启用的时间段。</p>
<img width="500" src="/images/浅析Golang的内存管理/10.png">

<p><code>gcStart()</code>函数有一个<code>gcTrigger</code>参数，这是GC的触发条件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A gcTrigger is a predicate for starting a GC cycle. Specifically,</span></span><br><span class="line"><span class="comment">// it is an exit condition for the _GCoff phase.</span></span><br><span class="line"><span class="keyword">type</span> gcTrigger <span class="keyword">struct</span> &#123;</span><br><span class="line">    kind gcTriggerKind</span><br><span class="line">    now  <span class="keyword">int64</span>  <span class="comment">// gcTriggerTime: current time</span></span><br><span class="line">    n    <span class="keyword">uint32</span> <span class="comment">// gcTriggerCycle: cycle number to start</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gcTrigger</code>的<code>kind</code>有三种，<code>gcTriggerHeap</code>、<code>gcTriggerTime</code>、<code>gcTriggerCycle</code>。</p>
<ul>
<li>gcTriggerHeap：当前分配的内存达到一定阈值时触发，这个阈值在每次GC过后都会根据堆内存的增长情况和CPU占用率来调整。</li>
<li>gcTriggerTime：自从上次GC后间隔时间达到<code>runtime.forcegcperiod</code>(120s，It normally doesn’t change.)，将启动GC。通过sysmon监控线程调用<code>runtime.forcegchelper</code>检查。</li>
<li>gcTriggerCycle：如果当前没有开启垃圾收集，则启动GC。</li>
</ul>
<h3 id="系统触发"><a href="#系统触发" class="headerlink" title="系统触发"></a>系统触发</h3><h4 id="内存分配触发"><a href="#内存分配触发" class="headerlink" title="内存分配触发"></a>内存分配触发</h4><p>从<code>src\runtime\malloc.go</code>的<code>mallocgc</code>函数可以看到，在为对象分配堆内存后，会检查GC的触发条件，如果满足条件，则开启<code>gcStart</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mallocgc</span><span class="params">(size <span class="keyword">uintptr</span>, typ *_type, needzero <span class="keyword">bool</span>)</span> <span class="title">unsafe</span>.<span class="title">Pointer</span></span> &#123; </span><br><span class="line">    ...</span><br><span class="line">    dataSize := size</span><br><span class="line">    <span class="comment">// 获取mcache，用于处理微对象和小对象的分配</span></span><br><span class="line">    c := gomcache()</span><br><span class="line">    <span class="keyword">var</span> x unsafe.Pointer</span><br><span class="line">    <span class="comment">// 表示对象是否包含指针，true表示对象里没有指针</span></span><br><span class="line">    noscan := typ == <span class="literal">nil</span> || typ.ptrdata == <span class="number">0</span></span><br><span class="line">    <span class="comment">// maxSmallSize=32768 32k</span></span><br><span class="line">    <span class="keyword">if</span> size &lt;= maxSmallSize &#123;</span><br><span class="line">        <span class="comment">// maxTinySize= 16 bytes </span></span><br><span class="line">        <span class="keyword">if</span> noscan &amp;&amp; size &lt; maxTinySize &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 大于 32 Kb 的内存分配,通过 mheap 分配</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 在 GC 期间分配的新对象都会被标记成黑色</span></span><br><span class="line">    <span class="keyword">if</span> gcphase != _GCoff &#123;</span><br><span class="line">        gcmarknewobject(span, <span class="keyword">uintptr</span>(x), size, scanSize)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 检查GC触发条件</span></span><br><span class="line">    <span class="keyword">if</span> shouldhelpgc &#123;</span><br><span class="line">            <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerHeap&#125;); t.test() &#123;</span><br><span class="line">                    gcStart(t)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>gcStart</code>函数在上面已经分析过了。和手动调用的<code>GC()</code>中调用的<code>gcStart</code>函数是一样的。</p>
<p>在<code>mallocgc</code>中，通过调用<code>gcTrigger.test()</code>函数判断GC条件是否满足，满足则触发GC。上面已经提过<code>gcTrigger</code>的<code>kind</code>有三种，<code>gcTriggerHeap</code>、<code>gcTriggerTime</code>、<code>gcTriggerCycle</code>。只要满足其中一个<code>kind</code>就满足触发GC条件。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(t gcTrigger)</span> <span class="title">test</span><span class="params">()</span> <span class="title">bool</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> !memstats.enablegc || panicking != <span class="number">0</span> || gcphase != _GCoff &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> t.kind &#123;</span><br><span class="line">    <span class="keyword">case</span> gcTriggerHeap:</span><br><span class="line">        <span class="comment">// 当前分配的堆内存达到一定阈值(控制器计算的触发堆大小)</span></span><br><span class="line">        <span class="keyword">return</span> memstats.heap_live &gt;= memstats.gc_trigger</span><br><span class="line">    <span class="keyword">case</span> gcTriggerTime:</span><br><span class="line">        <span class="keyword">if</span> gcpercent &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        lastgc := <span class="keyword">int64</span>(atomic.Load64(&amp;memstats.last_gc_nanotime))</span><br><span class="line">        <span class="comment">// 自从上次GC后间隔时间已大于forcegcperiod</span></span><br><span class="line">        <span class="keyword">return</span> lastgc != <span class="number">0</span> &amp;&amp; t.now-lastgc &gt; forcegcperiod</span><br><span class="line">    <span class="keyword">case</span> gcTriggerCycle:</span><br><span class="line">        <span class="comment">// 要求启动新一轮的GC</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">int32</span>(t.n-work.cycles) &gt; <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>heap_live的值会在内存分配的时候进行计算。<br>gc_trigger的计算是通过<code>runtime.gcSetTriggerRatio()</code>函数。<code>gcSetTriggerRatio</code>函数会根据计算出来的<code>triggerRatio</code>来获取下次触发GC的堆大小是多少。<code>triggerRatio</code>是通过<code>gcControllerState.endCycle()</code>函数(<code>triggerRatio</code>每次GC后都会调整)。</p>
</blockquote>
<h4 id="监控线程sysmon触发"><a href="#监控线程sysmon触发" class="headerlink" title="监控线程sysmon触发"></a>监控线程sysmon触发</h4><p>在<code>runtime.main()</code>函数中，执行<code>init</code>前，会启动sysmon监控线程，执行后台监控任务。</p>
<p>代码在<code>src/runtime/proc.go</code>。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    systemstack(<span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建监控线程，该线程独立于调度器，不需要跟p关联即可运行</span></span><br><span class="line">        newm(sysmon, <span class="literal">nil</span>, <span class="number">-1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">sysmon</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="comment">// 检查是否满足GC条件(GC间隔已超过gcTriggerTime)</span></span><br><span class="line">        <span class="keyword">if</span> t := (gcTrigger&#123;kind: gcTriggerTime, now: now&#125;); t.test() &amp;&amp; atomic.Load(&amp;forcegc.idle) != <span class="number">0</span> &#123;</span><br><span class="line">            lock(&amp;forcegc.lock)</span><br><span class="line">            forcegc.idle = <span class="number">0</span></span><br><span class="line">            <span class="keyword">var</span> list gList</span><br><span class="line">            <span class="comment">// 将forcegc.g这个goroutine添加到全局队列里等待被调度</span></span><br><span class="line">            list.push(forcegc.g)</span><br><span class="line">            injectglist(&amp;list)</span><br><span class="line">            unlock(&amp;forcegc.lock)</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>runtime</code>在启动时，会在一个初始化函数<code>init()</code>里启用一个<code>forcegchelper()</code>函数。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// start forcegc helper goroutine</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">init</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> forcegchelper()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 大部分时候陷入休眠，会被sysmon在满足GC条件时唤醒</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">forcegchelper</span><span class="params">()</span></span> &#123;</span><br><span class="line">    forcegc.g = getg() <span class="comment">// 指定forcegc的goroutine</span></span><br><span class="line">    lockInit(&amp;forcegc.lock, lockRankForcegc)</span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        lock(&amp;forcegc.lock)</span><br><span class="line">        <span class="keyword">if</span> forcegc.idle != <span class="number">0</span> &#123;</span><br><span class="line">            throw(<span class="string">"forcegc: phase error"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将forcegc设置为空闲状态，并进入休眠</span></span><br><span class="line">        atomic.Store(&amp;forcegc.idle, <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 为了减少系统资源占用，主动让自己陷入休眠，等待唤醒</span></span><br><span class="line">        <span class="comment">// 由sysmon监控线程根据条件来恢复这个gc goroutine</span></span><br><span class="line">        goparkunlock(&amp;forcegc.lock, waitReasonForceGCIdle, traceEvGoBlock, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> debug.gctrace &gt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">println</span>(<span class="string">"GC forced"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当forcegc.g被唤醒时，开始从此处进行调度完全并发</span></span><br><span class="line">        gcStart(gcTrigger&#123;kind: gcTriggerTime, now: nanotime()&#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>我是这么理解的，<code>forcegc</code>是一个全局变量，所以<code>forcegchelper</code>可以由sysmon监控线程。在sysmon监控中，如果GC满足条件，会设置<code>forcegc.idle = 0</code>，一旦<code>forcegc.g</code>被唤醒，<code>forcegchelper</code>就会执行<code>gcStart</code>。</p>
</blockquote>
<h2 id="调节GC参数"><a href="#调节GC参数" class="headerlink" title="调节GC参数"></a>调节GC参数</h2><p>Go的GC算法是固定的，用户无法去配置采用什么算法。GC相关的配置参数只有<code>GOGC</code>，用来表示触发GC的条件。</p>
<p><code>src\runtime\mgc.go</code>的开头有这样一段注释。</p>
<blockquote>
<p>Next GC is after we’ve allocated an extra amount of memory proportional to the amount already in use. The proportion is controlled by GOGC environment variable(100 by default). If GOGC=100 and we’re using 4M, we’ll GC again when we get to 8M(this mark is tracked in next_gc variable). This keeps the GC cost in linear proportion to the allocation cost. Adjusting GOGC just changes the linear constant (and also the amount of extra memory used).</p>
</blockquote>
<p>下次GC的时机通过环境变量<code>GOGC</code>来控制，默认是100，即增长100%的堆内存才会触发GC。如果当前使用了4M内存，那么下次GC将会在内存达到8M的时候。设置<code>GOGC=off</code>将完全禁用GC。</p>
<p>也可以通过<code>src/runtime/debug</code>中的<code>func SetGCPercent(percent int) int</code>函数设置，设置负数将完全禁用GC。</p>
<p>增大GOGC，虽然可以降低GC频率，但是会增加触发GC的堆大小，可能会导致OOM，需要根据实际情况调节。</p>
<h2 id="如何观察GC"><a href="#如何观察GC" class="headerlink" title="如何观察GC"></a>如何观察GC</h2><p>可以通过不同的方法来观察GC。</p>
<h3 id="GODEBUG-gctrace-1"><a href="#GODEBUG-gctrace-1" class="headerlink" title="GODEBUG=gctrace=1"></a>GODEBUG=gctrace=1</h3><p>将<code>GODEBUG</code>设置为<code>gctrace=1</code>。两种方式：</p>
<ul>
<li><code>export GODEBUG=gctrace=1</code></li>
<li><code>GODEBUG=gctrace=1 ./main</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">gc # @#s #%: #+#+# ms clock, #+#&#x2F;#&#x2F;#+# ms cpu, #-&gt;#-&gt;# MB, # MB goal, # P</span><br><span class="line">where the fields are as follows:</span><br><span class="line">    gc #        the GC number, incremented at each GC</span><br><span class="line">    @#s         time in seconds since program start</span><br><span class="line">    #%          percentage of time spent in GC since program start</span><br><span class="line">    #+...+#     wall-clock&#x2F;CPU times for the phases of the GC</span><br><span class="line">    #-&gt;#-&gt;# MB  heap size at GC start, at GC end, and live heap</span><br><span class="line">    # MB goal   goal heap size</span><br><span class="line">    # P         number of processors used</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ GODEBUG&#x3D;gctrace&#x3D;1 .&#x2F;main</span><br><span class="line">...</span><br><span class="line">&#x2F;&#x2F; gc 3: 第三个gc周期</span><br><span class="line">&#x2F;&#x2F; @0.002s: 程序开始后的0.002s</span><br><span class="line">&#x2F;&#x2F; 3%: 该GC周期中的CPU使用率</span><br><span class="line">&#x2F;&#x2F; 0.031+0.059+0.002 ms clock: 标记开始时STW所花的时间 + 标记过程中并发标记所花的时间 + 标记终止时STW所花的时间。总和是wall clock(实际的时间)。</span><br><span class="line">&#x2F;&#x2F; 0.12+0.040&#x2F;0.024&#x2F;0+0.009 ms cpu: 标记开始时STW所花的时间 + 标记过程中标记辅助所花的时间&#x2F;标记过程中并发标记所花的时间&#x2F;标记过程中GC空闲的时间 + 标记终止时STW所花的时间。总和是cpu time。</span><br><span class="line">&#x2F;&#x2F; 4-&gt;4-&gt;0 MB: 标记开始时堆大小的实际值&#x2F;标记结束时堆大小的实际值&#x2F;标记结束时标记为存活的堆大小</span><br><span class="line">&#x2F;&#x2F; 5 MB goal: 标记结束时堆的大小的目标值</span><br><span class="line">&#x2F;&#x2F; 4 P: 使用的P的数量</span><br><span class="line">gc 3 @0.002s 3%: 0.031+0.059+0.002 ms clock, 0.12+0.040&#x2F;0.024&#x2F;0+0.009 ms cpu, 4-&gt;4-&gt;0 MB, 5 MB goal, 4 P</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; scvg: runtime向操作系统申请内存产生的垃圾回收，向操作系统归还多余的内存</span><br><span class="line">&#x2F;&#x2F; 向操作系统归还了0MB内存</span><br><span class="line">scvg: 0 MB released</span><br><span class="line">&#x2F;&#x2F; inuse: 1 已经分配给用户代码、正在使用的总内存大小(MB)</span><br><span class="line">&#x2F;&#x2F; idle: 62 空闲以及等待归还给操作系统的总内存大小(MB)</span><br><span class="line">&#x2F;&#x2F; sys: 63 通知操作系统中保留的内存大小(MB)</span><br><span class="line">&#x2F;&#x2F; released: 58 已经归还给操作系统的内存大小(MB)</span><br><span class="line">&#x2F;&#x2F; consumed: 5 (MB) 已经从操作系统中申请的内存大小(MB)</span><br><span class="line">scvg: inuse: 1, idle: 62, sys: 63, released: 58, consumed: 5 (MB)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="go-tool-trace"><a href="#go-tool-trace" class="headerlink" title="go tool trace"></a>go tool trace</h3><p>从标准库导入<code>runtime/trace</code>，并添加几行模板代码。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"><span class="keyword">import</span> (    </span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"runtime/trace"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, err := os.Create(<span class="string">"trace.out"</span>)    </span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">defer</span> f.Close()</span><br><span class="line">  err = trace.Start(f)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="built_in">panic</span>(err)</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">defer</span> trace.Stop()  </span><br><span class="line">  <span class="comment">// Your program here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序会在<code>trace.out</code>文件中写入事件数据。 然后运行<code>go tool trace trace.out</code>，将解析跟踪文件，该命令将启动服务器，并使用跟踪数据来响应可视化操作。</p>
<h2 id="内存泄露的情况"><a href="#内存泄露的情况" class="headerlink" title="内存泄露的情况"></a>内存泄露的情况</h2><p>C/C++这种没有原生GC的语言，如果程序员没有及时手动释放堆内存，可能会导致内存泄露最终OOM。Go虽然有GC，但是也可能发生内存泄露。Go程序的内存泄露是因为：预期的能很快被释放的内存由于附着在了长期存活的内存上或生命期意外地被延长，导致预计能够立即回收的内存而长时间得不到回收。举例说明三种情况。</p>
<ul>
<li>情况1</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = <span class="keyword">map</span>[<span class="keyword">interface</span>&#123;&#125;]<span class="keyword">interface</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keepalloc1</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++ &#123;</span><br><span class="line">        m := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">1</span>&lt;&lt;<span class="number">10</span>)</span><br><span class="line">        <span class="comment">// 全局变量cache被引用，没有得到迅速释放</span></span><br><span class="line">        cache[i] = m</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>情况2</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keepalloc2</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 不断产生新的goroutine，且不结束已经创建的goroutine并复用这部分内存</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">select</span> &#123;&#125;</span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>情况3</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ch = <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">keepalloc3</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++ &#123;</span><br><span class="line">        <span class="comment">// 没有接收方，goroutine会一直阻塞</span></span><br><span class="line">        <span class="comment">// 该goroutine会被永久的休眠，整个goroutine及其执行栈都得不到释放</span></span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>go tool trace</code>验证一下。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line">    <span class="string">"runtime/trace"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    f, _ := os.Create(<span class="string">"trace.out"</span>)</span><br><span class="line">    <span class="keyword">defer</span> f.Close()</span><br><span class="line">    trace.Start(f)</span><br><span class="line">    <span class="keyword">defer</span> trace.Stop()</span><br><span class="line">    keepalloc1()</span><br><span class="line">    keepalloc2()</span><br><span class="line">    keepalloc3()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用<code>go tool trace trace.out</code>命令得到下图。可以看到，运行过程中Heap持续增长，没有被回收，产生了内存泄漏。</p>
<img width="1000" src="/images/浅析Golang的内存管理/11.png">

<h2 id="Go的逃逸分析"><a href="#Go的逃逸分析" class="headerlink" title="Go的逃逸分析"></a>Go的逃逸分析</h2><p>Go的逃逸分析指的是编译器执行静态代码分析后，对内存管理进行的优化和简化，决定一个变量是分配到堆上还是栈上。通过逃逸分析，可以把不需要分配到堆上的变量分配到栈上，减轻分配堆内存的开销，同时也减少GC的压力，提高程序的性能。</p>
<blockquote>
<p>How do I know whether a variable is allocated on the heap or the stack?<br>From a correctness standpoint, you don’t need to know. Each variable in Go exists as long as there are references to it. The storage location chosen by the implementation is irrelevant to the semantics of the language.<br>The storage location does have an effect on writing efficient programs. When possible, the Go compilers will allocate variables that are local to a function in that function’s stack frame. However, if the compiler cannot prove that the variable is not referenced after the function returns, then the compiler must allocate the variable on the garbage-collected heap to avoid dangling pointer errors. Also, if a local variable is very large, it might make more sense to store it on the heap rather than the stack.</p>
</blockquote>
<p>从官方的回答，可以看出Go逃逸分析基本的原则是：</p>
<ul>
<li>如果一个函数返回的变量被外部引用，那么它就会发生逃逸，被分配到堆上。</li>
<li>如果函数的局部变量非常大，也可能被分配到堆上。</li>
</ul>
<p>Go的new函数分配的内存不一定在堆上。即使用new申请到的内存，如果在退出函数后没有用了，就会被分配到栈上；即使是一个普通的变量，但是逃逸分析发现在退出函数之后还有其他地方在引用，就被分配到堆上。</p>
<p>举个栗子。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">test</span><span class="params">()</span> *<span class="title">int</span></span> &#123;</span><br><span class="line">    a := <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> &amp;a</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    b := test()</span><br><span class="line">    fmt.Println(*b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ go build -gcflags &#39;-m -l&#39; demo.go</span><br><span class="line"># command-line-arguments</span><br><span class="line">.&#x2F;demo.go:6:2: moved to heap: a</span><br><span class="line">.&#x2F;demo.go:11:13: ... argument does not escape</span><br><span class="line">.&#x2F;demo.go:11:14: *b escapes to heap</span><br></pre></td></tr></table></figure>

<p>通过查看逃逸分析结果看出：</p>
<ul>
<li><code>test</code>函数里的变量a逃逸了。因为<code>test</code>函数返回了a的地址。</li>
<li>main函数里的<code>b</code>也逃逸了。因为<code>func Println(a ...interface{})</code>参数为<code>interface{}</code>类型，编译期间不能确定其参数的类型，也会发生逃逸。</li>
</ul>
<blockquote>
<p>这个栗子只是逃逸分析里最简单的情况。</p>
</blockquote>
<h2 id="GC调优"><a href="#GC调优" class="headerlink" title="GC调优"></a>GC调优</h2><h3 id="调优思想"><a href="#调优思想" class="headerlink" title="调优思想"></a>调优思想</h3><p>并非所有程序都需要关注GC，只有以下两种情况需要对GC进行性能调优。</p>
<ul>
<li>对停顿敏感：用户代码需要实时性，无法接受GC长时间STW。</li>
<li>对CPU资源消耗敏感：对于频繁分配内存的应用，影响用户代码对CPU的利用率。</li>
</ul>
<p>所以，针对这两点，除了降低GC频率(通过增大GOGC的值)，GC调优的核心就是：</p>
<ul>
<li>控制：优化内存的申请速度</li>
<li>减少：尽可能少申请内存，比如初始化至合适的大小，尽量使用引用传递</li>
<li>复用：复用已申请的内存</li>
</ul>
<h3 id="一些优化"><a href="#一些优化" class="headerlink" title="一些优化"></a>一些优化</h3><ol>
<li>对于频繁分配内存的对象，可以使用<code>sync.Pool</code>进行内存复用，减少分配内存频次，从而降低GC频率。</li>
<li>控制内存分配的速度，限制goroutine的数量，从而提高赋值器对CPU的利用率。</li>
<li><code>slice</code>和<code>map</code>等结构提前分配足够的内存，降低扩容时多余的拷贝。</li>
<li>不逃逸的对象分配在栈上，当函数返回时就回收了资源，不需要GC标记清除，减少GC频率。</li>
<li>避免<code>string</code>与<code>[]byte</code>转换，两者发生转换的时候，底层数据结结构会进行复制，因此导致GC效率会变低（有优化的方法）。</li>
<li>少量使用<code>+</code>连接string。因为string是一个只读类型，Go不能直接修改string类似变量的内存空间，针对它的每一个操作都会创建一个新的string。如果是大量小文本拼接，用<code>strings.Join</code>；如果是大量大文本拼接，用<code>bytes.Buffer</code>。</li>
</ol>
<blockquote>
<p>GC优化点不只这些，等我研究一下有时间再细讲。</p>
</blockquote>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>[1]. <a href="https://draveness.me/golang/" target="_blank" rel="noopener">https://draveness.me/golang/</a><br>[2]. <a href="https://www.luozhiyun.com/archives/475" target="_blank" rel="noopener">https://www.luozhiyun.com/archives/475</a><br>[3]. <a href="https://golang.design/under-the-hood/zh-cn/part2runtime/ch08gc/pacing/" target="_blank" rel="noopener">https://golang.design/under-the-hood/zh-cn/part2runtime/ch08gc/pacing/</a><br>[4]. <a href="https://www.kancloud.cn/aceld/golang/1958308" target="_blank" rel="noopener">https://www.kancloud.cn/aceld/golang/1958308</a><br>[5]. <a href="https://pkg.go.dev/runtime?utm_source=godoc" target="_blank" rel="noopener">https://pkg.go.dev/runtime?utm_source=godoc</a><br>[6]. <a href="https://www.bookstack.cn/read/qcrao-Go-Questions/GC-GC.md" target="_blank" rel="noopener">https://www.bookstack.cn/read/qcrao-Go-Questions/GC-GC.md</a><br>[7]. <a href="https://golang.org/doc/faq#stack_or_heap" target="_blank" rel="noopener">https://golang.org/doc/faq#stack_or_heap</a></p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div></div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="Pearl 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Pearl 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    Pearl
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://pearlzju.github.io/2021/06/28/%E6%B5%85%E6%9E%90Golang%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E4%BA%8C)/" title="浅析Golang的内存管理(二)">https://pearlzju.github.io/2021/06/28/%E6%B5%85%E6%9E%90Golang%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E4%BA%8C)/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Golang/" rel="tag"># Golang</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2021/06/26/%E6%B5%85%E6%9E%90Golang%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E4%B8%80)/" rel="next" title="浅析Golang的内存管理(一)">
                <i class="fa fa-chevron-left"></i> 浅析Golang的内存管理(一)
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2021/07/03/Crash%20Course%20Computer%20Science/" rel="prev" title="Crash Course Computer Science">
                Crash Course Computer Science <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/face.jpeg"
                alt="Pearl" />
            
              <p class="site-author-name" itemprop="name">Pearl</p>
              <p class="site-description motion-element" itemprop="description">爱自己是终身浪漫的开始</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">9</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">1</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Pearlzju" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:shanglin@zju.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/LINZJU" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.douban.com/people/104033946" target="_blank" title="豆瓣">
                      
                        <i class="fa fa-fw fa-globe"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#引言"><span class="nav-number">1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#垃圾回收"><span class="nav-number">2.</span> <span class="nav-text">垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">2.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#标记-清除算法"><span class="nav-number">2.2.</span> <span class="nav-text">标记-清除算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GC流程"><span class="nav-number">2.2.1.</span> <span class="nav-text">GC流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点"><span class="nav-number">2.2.2.</span> <span class="nav-text">缺点</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三色标记算法"><span class="nav-number">2.3.</span> <span class="nav-text">三色标记算法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GC流程-1"><span class="nav-number">2.3.1.</span> <span class="nav-text">GC流程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#缺点-1"><span class="nav-number">2.3.2.</span> <span class="nav-text">缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#强-弱三色不变式"><span class="nav-number">2.3.3.</span> <span class="nav-text">强-弱三色不变式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#强三色不变式"><span class="nav-number">2.3.3.1.</span> <span class="nav-text">强三色不变式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#弱三色不变式"><span class="nav-number">2.3.3.2.</span> <span class="nav-text">弱三色不变式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#三色标记算法-屏障机制"><span class="nav-number">2.4.</span> <span class="nav-text">三色标记算法+屏障机制</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#插入屏障机制"><span class="nav-number">2.4.1.</span> <span class="nav-text">插入屏障机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除屏障机制"><span class="nav-number">2.4.2.</span> <span class="nav-text">删除屏障机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#混合写屏障机制"><span class="nav-number">2.4.3.</span> <span class="nav-text">混合写屏障机制</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#何时触发GC"><span class="nav-number">2.5.</span> <span class="nav-text">何时触发GC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#手动触发"><span class="nav-number">2.5.1.</span> <span class="nav-text">手动触发</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#系统触发"><span class="nav-number">2.5.2.</span> <span class="nav-text">系统触发</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#内存分配触发"><span class="nav-number">2.5.2.1.</span> <span class="nav-text">内存分配触发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#监控线程sysmon触发"><span class="nav-number">2.5.2.2.</span> <span class="nav-text">监控线程sysmon触发</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调节GC参数"><span class="nav-number">2.6.</span> <span class="nav-text">调节GC参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#如何观察GC"><span class="nav-number">2.7.</span> <span class="nav-text">如何观察GC</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#GODEBUG-gctrace-1"><span class="nav-number">2.7.1.</span> <span class="nav-text">GODEBUG&#x3D;gctrace&#x3D;1</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#go-tool-trace"><span class="nav-number">2.7.2.</span> <span class="nav-text">go tool trace</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#内存泄露的情况"><span class="nav-number">2.8.</span> <span class="nav-text">内存泄露的情况</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Go的逃逸分析"><span class="nav-number">2.9.</span> <span class="nav-text">Go的逃逸分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#GC调优"><span class="nav-number">2.10.</span> <span class="nav-text">GC调优</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#调优思想"><span class="nav-number">2.10.1.</span> <span class="nav-text">调优思想</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#一些优化"><span class="nav-number">2.10.2.</span> <span class="nav-text">一些优化</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">3.</span> <span class="nav-text">Reference</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pearl</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'ECUWkqa8FVLG7NN721RUeTXk-gzGzoHsz',
        appKey: 'BEMbJ6wNDs62iTOP3UAxzVle',
        placeholder: '说点什么呢',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("ECUWkqa8FVLG7NN721RUeTXk-gzGzoHsz", "BEMbJ6wNDs62iTOP3UAxzVle");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
