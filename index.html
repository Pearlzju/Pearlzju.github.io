<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="爱自己是终身浪漫的开始">
<meta property="og:type" content="website">
<meta property="og:title" content="Pearl 的个人小站">
<meta property="og:url" content="https://pearlzju.github.io/index.html">
<meta property="og:site_name" content="Pearl 的个人小站">
<meta property="og:description" content="爱自己是终身浪漫的开始">
<meta property="article:author" content="Pearl">
<meta name="twitter:card" content="summary">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"right","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://pearlzju.github.io/"/>





  <title>Pearl 的个人小站</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?e99d362e55bda406e16937db2b48aebc";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




<meta name="generator" content="Hexo 4.2.1"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Pearl 的个人小站</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">终身学习者</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pearlzju.github.io/2021/06/13/%E3%80%8AKubernetes%20In%20Action%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Pearl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/face.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pearl 的个人小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/13/%E3%80%8AKubernetes%20In%20Action%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" itemprop="url">《Kubernetes In Action》阅读笔记</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-13T10:17:28+08:00">
                2021-06-13
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/06/13/%E3%80%8AKubernetes%20In%20Action%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/06/13/%E3%80%8AKubernetes%20In%20Action%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2021/06/13/%E3%80%8AKubernetes%20In%20Action%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="leancloud_visitors" data-flag-title="《Kubernetes In Action》阅读笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<blockquote>
<p>本文是把《Kubernetes In Action》读薄的摘抄、转述和理解，仅供参考。系统学习请阅读原书。<br>k8s中的命令繁多，熟练使用它们和理解k8s设计思想同等重要，每章最后总结了该章涉及的命令。</p>
</blockquote>
<img width="300" src="/images/Kubernetes In Action阅读笔记/0.png">

<h1 id="阅读之前"><a href="#阅读之前" class="headerlink" title="阅读之前"></a>阅读之前</h1><p>2019~2020年期间，在工作上使用过Istio来治理微服务，Istio与Kubernetes(k8s)紧密集合。我们的业务是一个云计算Iass和Paas平台，我们把计算、网络、存储、安全、数据库、负载均衡和监控等模块拆分成微服务，用k8s管理，每个组件以pod的形式独立部署。当时我只是在项目中应用了istio+k8s，没有系统学习过k8s的设计思想。最近因为工作原因，再次接触k8s，于是挑选了《Kubernetes In Action》进行系统学习和温故而知新，这确实是一本不多见的涵盖广阔提纲挈领的好书。</p>
<p>微服务架构，它从管理上获取对服务的抽象，方便服务的管理和规划服务的边界。但它因为引入了很多新的机制，比如注册中心等，其实对硬件而言是一种牺牲。舍弃一定的性能，换来的是服务的治理、团队协作开发的方便，这就是微服务架构的价值。</p>
<p>程序的本质从不同角度观察，会有不同的见解，就像光的波粒二象性。我的观点是不浪费硬件是对提升性能最大的帮助。会有听到微服务解决了高并发问题的说法，但微服务和高并发其实没有必然关系。而是因为通常微服务会使用分布式方式部署，硬件资源包括CPU、网络、磁盘等成倍增加，所以分布式对高并发问题有积极作用。</p>
<p>Istio，它其实不局限于微服务治理范畴，任何服务，只要服务间有访问，需要对服务间的通信进行管理，都可以使用Istio。</p>
<p>k8s不是一个专为Docker设计的容器编排系统。k8s的核心也不止是编排容器，只不过容器恰好是在不同集群节点上运行应用的最佳方式。k8s可以被看作集群的一个操作系统，提供服务发现、扩容、负载均衡、自恢复、leader选举等功能。</p>
<h1 id="1-Kubernetes-介绍-1"><a href="#1-Kubernetes-介绍-1" class="headerlink" title="1 Kubernetes 介绍 1"></a>1 Kubernetes 介绍 1</h1><p>微服务架构是替代以单个进程或几个进程运行在服务器上为部署方式的单体应用的一种方式，它将单体应用分解成若干个可独立运行组件。微服务的解耦性，确保它们可以被独立开发、部署、升级、伸缩。<br>如何部署、管理这些微服务，并充分利用宿主机的硬件资源，诞生了k8s。k8s可以理解为是一个数据中心操作系统(DCOS)，他将人员分为开发人员和系统管理员，系统管理员负责处理和硬件、集群相关的事务，开发人员只需要提交自己的应用和描述。k8s会「自动」按照开发人员的描述，把应用启动起来，并暴露定义的端口。</p>
<blockquote>
<p>在computer science领域，有一句话”All problems in computer science can be solved by another level of indirection”。k8s抽象了数据中心的硬件基础设置，对外暴露资源池API，开发人员不用关心底层的硬件设施。这种抽象和操作系统也有相似之处。</p>
</blockquote>
<h2 id="1-1-Kubernetes-系统的需求-2"><a href="#1-1-Kubernetes-系统的需求-2" class="headerlink" title="1.1 Kubernetes 系统的需求 2"></a>1.1 Kubernetes 系统的需求 2</h2><h3 id="1-1-1-从单体应用到微服务-2"><a href="#1-1-1-从单体应用到微服务-2" class="headerlink" title="1.1.1 从单体应用到微服务 2"></a>1.1.1 从单体应用到微服务 2</h3><p>对于单体应用，为了提升系统负载能力，有两种扩展方式。<br>垂直扩展：增加CPU、内存或其它系统资源。应用程序无需变化，但成本越来越高，无法无限扩展。<br>水平扩展：经常需要应用程序进行改动才可执行，可能会被某个模块无法水平扩展限制。</p>
<p>单体应用可被拆分成多个可独立部署、以独立进程运行的微服务，微服务之间以约定的API通信。</p>
<p>对于微服务架构，可以只扩容某些服务，因为扩容粒度细化，可以根据具体情况分配扩容资源。</p>
<blockquote>
<p>如果有历史项目是单体应用，不得不水平扩容，而水平扩容受到某些模块的限制。可以把应用拆分成多个微服务，对能扩容的组件水平扩展，对不能扩容的组件垂直扩展。</p>
</blockquote>
<p>看似一切很美好，微服务带来的弊端不容忽视。<br>当服务数量激增，如何处理服务间错综复杂的依赖关系，如何把正确的配置应用到每个服务，如何调试代码和定位异常调用，如何解决不同服务对于环境需求的差异，都是需要面对的。</p>
<h3 id="1-1-2-为应用程序提供一个一致的环境-5"><a href="#1-1-2-为应用程序提供一个一致的环境-5" class="headerlink" title="1.1.2 为应用程序提供一个一致的环境 5"></a>1.1.2 为应用程序提供一个一致的环境 5</h3><p>目标是让服务在开发和生产阶段可以运行在完全一样的环境下，有完全一样的操作系统、库、系统配置、网络环境等。各个服务之间独立互不影响。</p>
<h3 id="1-1-3-迈向持续交付-：DevOps-和无运维-6"><a href="#1-1-3-迈向持续交付-：DevOps-和无运维-6" class="headerlink" title="1.1.3 迈向持续交付 ：DevOps 和无运维 6"></a>1.1.3 迈向持续交付 ：DevOps 和无运维 6</h3><p>让应用开发者和系统管理员解耦，开发者可以自己参与配置和部署程序，但又无需关注硬件基础设施。而实际上系统管理员在幕后保证底层基础设施正常运转，但他们也无需关注运行的程序本身。<br>这正是k8s实现的功能。它对硬件资源进行抽象，对外暴露成一个平台，用于部署和运行应用程序。</p>
<h2 id="1-2-介绍容器技术-7"><a href="#1-2-介绍容器技术-7" class="headerlink" title="1.2 介绍容器技术 7"></a>1.2 介绍容器技术 7</h2><p>k8s使用Linux容器技术来实现对应用的隔离。</p>
<h3 id="1-2-1-什么是容器-7"><a href="#1-2-1-什么是容器-7" class="headerlink" title="1.2.1 什么是容器 7"></a>1.2.1 什么是容器 7</h3><p>虚拟机可以隔离不同的微服务环境是显然的，Linux容器技术也可以。容器和虚拟机相比开销小很多，容器里运行的进程实际上运行在宿主机上，但是和其它进程隔离，开销仅是容器消耗的资源。</p>
<p>虚拟机和容器中的应用进程对CPU的使用方式不同。每个虚拟机对应的Linux内核不一样，而不同容器对应的Linux内核一样（存在安全隐患）。如图所示。</p>
<img width="400" src="/images/Kubernetes In Action阅读笔记/1.png">

<p>如果多个进程运行在同一个操作系统上，是怎么利用容器是隔离它们的？有两个机制可用。</p>
<ol>
<li>Linux命名空间。可以在某个命名空间运行一个进程，进程只能看到这个命名空间下的资源。当然，会存在多种类型的命名空间，所以一个进程不单单只属于某一个命名空间，而属于每个类型的一个命名空间。</li>
</ol>
<p>存在以下类型的命名空间：</p>
<ul>
<li>Mount（mnt）</li>
<li>Process ID（pid）</li>
<li>Network（net）</li>
<li>Inter-process communicaion（ipd）</li>
<li>UTS</li>
<li>User ID（user）</li>
</ul>
<ol start="2">
<li>内核的cgroups。限制进程能使用的资源量（CPU、内存、网络带宽等）不能超过被分配的量。</li>
</ol>
<h3 id="1-2-2-Docker-容器平台介绍-11"><a href="#1-2-2-Docker-容器平台介绍-11" class="headerlink" title="1.2.2 Docker 容器平台介绍 11"></a>1.2.2 Docker 容器平台介绍 11</h3><p>Docker是第一个使容器成为主流的容器平台。Docker本身不提供进程隔离，而是由Linux命名空间和cgroups之类的内核特性完成。</p>
<p>镜像层是只读的。容器运行时，一个新的可写层在镜像层之上被创建。 容器中进程写入位于底层的一个文件时，此文件的一个拷贝在顶层被创建，进程写的是此拷贝。</p>
<p>Docker可以借助于镜像在不同操作系统之间移植，但是内核由运行容器的宿主机决定。如果一个容器化的应用需要一个特定的内核版本，那它可能不能在每台机器上都工作。 如果一台机器上运行了一个不匹配的 Linux 内核版本，或者没有相同内核模块可用，那么此应用就不能在其上运行。所以容器镜像存在移植性的限制，在不同CPU架构上构建的镜像不能通用。例如在x86平台构建的镜像，不能在arm平台使用。</p>
<h3 id="1-2-3-rkt——一个-Docker-的替代方案-14"><a href="#1-2-3-rkt——一个-Docker-的替代方案-14" class="headerlink" title="1.2.3 rkt——一个 Docker 的替代方案 14"></a>1.2.3 rkt——一个 Docker 的替代方案 14</h3><p>开放容器计划OCI是围绕容器格式和运行时创建的开放工业标准。kubelet以CRI标准接口与OCI进行通信。rkt是另一个Linux容器引擎。</p>
<p>本书集中使用Docker作为k8s的容器，它是k8s最初唯一支持的容器类型，但k8s目前也支持rkt等其它容器类型。</p>
<h2 id="1-3-Kubernetes-介绍-15"><a href="#1-3-Kubernetes-介绍-15" class="headerlink" title="1.3 Kubernetes 介绍 15"></a>1.3 Kubernetes 介绍 15</h2><h3 id="1-3-1-初衷-15"><a href="#1-3-1-初衷-15" class="headerlink" title="1.3.1 初衷 15"></a>1.3.1 初衷 15</h3><p>在海量服务器规模下，有效处理部署管理，并提高基础设施利用率。</p>
<h3 id="1-3-2-深入浅出地了解-Kubernetes-15"><a href="#1-3-2-深入浅出地了解-Kubernetes-15" class="headerlink" title="1.3.2 深入浅出地了解 Kubernetes 15"></a>1.3.2 深入浅出地了解 Kubernetes 15</h3><p>k8s整个系统由一个主节点和若干个工作节点组成。开发者把一个应用列表提交到主节点，k8s会将它们部署到集群的工作节点。组件被部署在哪个节点对于开发者和系统管理员来说都不用关心 。开发者能指定一些应用必须一起运行，k8s将会在一个工作节点上部署它们。其他的将被分散部署到集群中，但是不管部署在哪儿，它们都能以相同的方式互相通信。</p>
<img width="500" src="/images/Kubernetes In Action阅读笔记/2.png">

<h3 id="1-3-3-Kubernetes-集群架构-17"><a href="#1-3-3-Kubernetes-集群架构-17" class="headerlink" title="1.3.3 Kubernetes 集群架构 17"></a>1.3.3 Kubernetes 集群架构 17</h3><p>一个k8s集群由很多节点组成，分为两种类型：</p>
<ol>
<li>主节点：它承载着k8s控制和管理整个集群系统的控制面板。控制面板的组件持有井控制集群状态，但是它们不运行应用，运行应用是由工作节点完成的。</li>
</ol>
<ul>
<li>API服务器：应用和其它控制面板组件都要和它通信。</li>
<li>Scheculer：调度应用(为应用的每个可部署组件分配一个工作节点)。</li>
<li>Controller Manager：执行集群级别的功能，如复制组件、持续跟踪工作节点、处理节点失败等。</li>
<li>etcd：一个可靠的分布式数据存储，它能持久化存储集群配置。</li>
</ul>
<ol start="2">
<li>工作节点：它们运行用户实际部署的应用。</li>
</ol>
<ul>
<li>Docker、rkt或其它容器类型。</li>
<li>Kubelet：与API服务器通信，并管理它所在节点的容器。</li>
<li>kube-proxy：负责组件之间的负载均衡网络流量。</li>
</ul>
<img width="500" src="/images/Kubernetes In Action阅读笔记/3.png">

<h3 id="1-3-4-在-Kubernetes-中运行应用-18"><a href="#1-3-4-在-Kubernetes-中运行应用-18" class="headerlink" title="1.3.4 在 Kubernetes 中运行应用 18"></a>1.3.4 在 Kubernetes 中运行应用 18</h3><p>在向k8提交描述符之后，它将把每个pod的指定副本数量调度到可用的工作节点上。 节点上的 Kubelets将告知Docker从镜像仓库中拉取 容器镜像井运行容器。 </p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/4.png">

<p>一旦应用程序运行起来，k8s就会不断地确认应用程序的部署状态始终与你提供的描述相匹配。</p>
<p>k8s采用声明式的控制流，所有的资源声明都保存在etcd，所有的组件都通过API Server来声明或监听资源。只要资源被声明，那么监听资源的控制器就会开始工作，确保让各个资源实例达到声明的状态。</p>
<h3 id="1-3-5-使用-Kubernetes-的好处-20"><a href="#1-3-5-使用-Kubernetes-的好处-20" class="headerlink" title="1.3.5 使用 Kubernetes 的好处 20"></a>1.3.5 使用 Kubernetes 的好处 20</h3><ul>
<li>简化应用程序部署</li>
<li>更好地利用硬件</li>
<li>健康检查和自修复</li>
<li>自动扩容</li>
<li>敏捷交付</li>
</ul>
<h1 id="2-开始使用-Kubernetes-和-Docker-23"><a href="#2-开始使用-Kubernetes-和-Docker-23" class="headerlink" title="2 开始使用 Kubernetes 和 Docker 23"></a>2 开始使用 Kubernetes 和 Docker 23</h1><h2 id="2-1-创建、运行及共享容器镜像-23"><a href="#2-1-创建、运行及共享容器镜像-23" class="headerlink" title="2.1 创建、运行及共享容器镜像 23"></a>2.1 创建、运行及共享容器镜像 23</h2><p>容器中的进程是运行在主机操作系统上的，但是该进程的ID在主机上和容器中不同。容器使用独立的PID Linux命令空间并且有着独立的系列号，完全独立于进程树。</p>
<p>正如拥有独立的进程树一 样，每个容器也拥有独立的文件系统。在容器内列出 根目录的内容，只会展示容器内的文件，包括镜像内的所有文件，再加上容器运行时创建的任何文件(类似日志文件)。</p>
<p>使用是比较简单的，本文不赘述了。</p>
<h2 id="2-2-配置-Kubernetes-集群-34"><a href="#2-2-配置-Kubernetes-集群-34" class="headerlink" title="2.2 配置 Kubernetes 集群 34"></a>2.2 配置 Kubernetes 集群 34</h2><p>主要讲如何创建k8s集群，讲了两个方法：用 Minikube 运行一个本地单节点 Kubernetes 集群；用 Google Kubernetes Engine 托管 Kubernetes 集群。以及为kubectl 配置别名和命令行补齐，方便命令输入。</p>
<p>使用是比较简单的，本文不赘述了。</p>
<h2 id="2-3-在-Kubernetes-上运行第一个应用-40"><a href="#2-3-在-Kubernetes-上运行第一个应用-40" class="headerlink" title="2.3 在 Kubernetes 上运行第一个应用 40"></a>2.3 在 Kubernetes 上运行第一个应用 40</h2><h3 id="2-3-1-部署-Node-js-应用-40"><a href="#2-3-1-部署-Node-js-应用-40" class="headerlink" title="2.3.1 部署 Node.js 应用 40"></a>2.3.1 部署 Node.js 应用 40</h3><p>一个pod是一组紧密相关的容器，它们总是一起运行在同一个工作节点上，以及同一个Linux命名空间中。每个pod就像一个独立的逻辑机器，拥有自己的IP、主机名、进程等，运行一个独立的应用程序。应用程序可以是单个进程，运行在单个容器中，也可以是一个主应用进程或者其他支持进程，每个进程都在自己的容器中运行。一个pod的所有容器都运行在同一个逻辑机器上，而其它pod中的容器，即使运行在同 一个工作节点上，也会出现在不同的节点上 。</p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/5.png">

<p>当运行kubectl命令时，它通过向API服务器发送一个REST HTTP请求，在集群中创建一个新的ReplicationController对象。然后，ReplicationController创建了一个新的pod，调度器将其调度到 一个工作节点上。Kubelet看到pod被调度到节点上，就告知Docker从镜像中心中拉取指定的镜像，因为本地没有该镜像。下载镜像后，Docker创建并运行容器。</p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/6.png">

<h3 id="2-3-2-访问-Web-应用-43"><a href="#2-3-2-访问-Web-应用-43" class="headerlink" title="2.3.2 访问 Web 应用 43"></a>2.3.2 访问 Web 应用 43</h3><p>每个pod有自己的IP地址，但是这个地址是集群内部的，不能从集群外部访问。要让pod能够从外部访问，需要通过服务对象公开它，要创建一个LoadBalancer类型的服务。它将创建一个外部的负载均衡，外部可以通过负载均衡的公共IP访问pod。</p>
<h3 id="2-3-3-系统的逻辑部分-45"><a href="#2-3-3-系统的逻辑部分-45" class="headerlink" title="2.3.3 系统的逻辑部分 45"></a>2.3.3 系统的逻辑部分 45</h3><p>k8s的基本构件是pod，但是没有直接创建和使用pod。通过运行<code>kubectl run</code>命令，创建了一个ReplicationController，它用于创建pod实例 。为了使该pod能够从集群外部访问，需要让 k8s将 该ReplicationController管理的所有pod由一个服务对外暴露。服务表示一组或多组提供相同服务的pod的静态地址。到达服务IP和端口的请求将被转发到属于该服务的一个容器的IP和端口。</p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/7.png">

<h3 id="2-3-4-水平伸缩应用-46"><a href="#2-3-4-水平伸缩应用-46" class="headerlink" title="2.3.4 水平伸缩应用 46"></a>2.3.4 水平伸缩应用 46</h3><p>为了增加pod的副本数，需要改变ReplicationController期望的副本数。告诉k8s需要确保pod始终有三个实例在运行。成功后，请求会随机地切到不同的pod。</p>
<blockquote>
<p>应用本身需要支持水平伸缩。</p>
</blockquote>
<p>没有告诉k8s需要采取什么行动，也没有告诉k8s增加两个pod，只设置新的期望的实例数量并让 k8s决定需要采取哪些操作来实现期望的状态。这是k8s最基本的原则之一。不是告诉 k8s 应该执行什么操作，而是声明性地改变系统的期望状态，并让k8s检查当前的状态是否与期望的状态一致。在整个 k8s 世界中都是这样的——声明式设计。</p>
<h3 id="2-3-5-查看应用运行在哪个节点上-49"><a href="#2-3-5-查看应用运行在哪个节点上-49" class="headerlink" title="2.3.5 查看应用运行在哪个节点上 49"></a>2.3.5 查看应用运行在哪个节点上 49</h3><p>不管调度到哪个节点，容器中运行的所有应用都具有相同类型的操作系统。每个pod都有自己的IP，并且可以与任何其他pod通信，不论其他pod是运行在同一 个节点上，还是运行在另一个节点上。每个pod都被分配到所需的计算资源，因此这些资源是由一个节点提供还是由另一个节点提供，并没有任何区别。</p>
<h3 id="2-3-6-介绍-Kubernetes-dashboard-50"><a href="#2-3-6-介绍-Kubernetes-dashboard-50" class="headerlink" title="2.3.6 介绍 Kubernetes dashboard 50"></a>2.3.6 介绍 Kubernetes dashboard 50</h3><p>k8s的图形化用户界面。列出部署在集群中的所有pod、ReplicationController、服务和其他部署在集群中的对象， 以及创建、修改和删除它们。</p>
<h2 id="2-4-本章的k8s命令"><a href="#2-4-本章的k8s命令" class="headerlink" title="2.4 本章的k8s命令"></a>2.4 本章的k8s命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">########## 集群 ##########  </span><br><span class="line"></span><br><span class="line"># 展示集群信息</span><br><span class="line">$ kubectl cluster-info</span><br><span class="line"></span><br><span class="line"># 获取dashboard的URL</span><br><span class="line">$ kubectl cluster-info | grep dashboard</span><br><span class="line"></span><br><span class="line">########## node ##########  </span><br><span class="line"></span><br><span class="line"># 列出集群节点</span><br><span class="line">$ kubectl get nodes</span><br><span class="line"></span><br><span class="line">########## pod ##########  </span><br><span class="line"></span><br><span class="line"># 列出所有pod</span><br><span class="line">$ kubectl get pods</span><br><span class="line">可以加上 -o wide 选项请求其它列</span><br><span class="line"></span><br><span class="line"># 描述一个pod</span><br><span class="line">$ kubectl describe pod kubia-hczji</span><br><span class="line"></span><br><span class="line">########## service ##########  </span><br><span class="line"></span><br><span class="line"># 列出所有服务</span><br><span class="line">$ kubectl get services(缩写svc)</span><br><span class="line"></span><br><span class="line">########## ReplicationController ##########  </span><br><span class="line"></span><br><span class="line"># 创建一个ReplicationController</span><br><span class="line">$ kubectl run kubia --image&#x3D;luksa&#x2F;kubia --port&#x3D;8080 --generator&#x3D;run&#x2F;v1</span><br><span class="line"></span><br><span class="line"># 改变ReplicationController期望的副本数</span><br><span class="line">$ kubectl scale re kubia --replicas&#x3D;3</span><br><span class="line"></span><br><span class="line"># 列出ReplicationController</span><br><span class="line">$ kubectl get replicationcontroller(缩写rc)</span><br><span class="line"></span><br><span class="line">########## LoadBalancer ##########  </span><br><span class="line"></span><br><span class="line"># 创建LoadBalancer服务对象</span><br><span class="line">$ kubectl expose rc kubia --type&#x3D;LoadBalancer --name kubia-http</span><br></pre></td></tr></table></figure>

<h1 id="3-pod-：运行于-Kubernetes-中的容器-53"><a href="#3-pod-：运行于-Kubernetes-中的容器-53" class="headerlink" title="3 pod ：运行于 Kubernetes 中的容器 53"></a>3 pod ：运行于 Kubernetes 中的容器 53</h1><p>pod是k8s中最重要的核心概念，而其他对象仅仅是在管理、 暴露pod或被pod使用。</p>
<h2 id="3-1-介绍-pod-53"><a href="#3-1-介绍-pod-53" class="headerlink" title="3.1 介绍 pod 53"></a>3.1 介绍 pod 53</h2><p>当一个 pod包含多个容器时，这些容器总是运行于同一个工作节点上。一个pod绝不会跨越多个工作节点。</p>
<h3 id="3-1-1-为何需要-pod-54"><a href="#3-1-1-为何需要-pod-54" class="headerlink" title="3.1.1 为何需要 pod 54"></a>3.1.1 为何需要 pod 54</h3><p>容器被设计为每个容器只运行一个进程(除非进程本身产生子进程)。如果在单个容器中运行多个不相关的进程，那么保持所有进程运行、管理它们的日志等将会是我们的责任。例如，我们需要包含一种在进程崩溃时能够自动重启的机制。同时这些进程都将记录到相同的标准输出中， 而此时我们将很难确定每个进程分别记录了什么。<br>我们需要让每个进程运行于自己的容器中，而这就是Docker和k8s期望使用的方式。<br>pod是k8s调度的最小单位，一个 pod可以包含一个或多个容器。</p>
<h3 id="3-1-2-了解-pod-55"><a href="#3-1-2-了解-pod-55" class="headerlink" title="3.1.2 了解 pod 55"></a>3.1.2 了解 pod 55</h3><p>由于不能将多个进程聚集在一个单独的容器中，我们需要另一种更高级的结构来将容器绑定在一 起，并将它们作为一个单元进行管理，这就是pod背后的根本原理。</p>
<p>k8s通过配置Docker来让一个pod内的所有容器共享相同的Linux命名空间，而不是每个容器都有自己的一组命名空间。</p>
<p>由于一个pod中的所有容器都在相同的network和UTS命名空间下运行，所以它们都共享相同的主机名和网络接口。 同一个pod中的容器共享相同的IP地址和端口空间。同样地，这些容器也都在相同的IPC命名空间下运行，因此能够通过IPC进行通信。在最新的k8s和Docker版本中，它们也能够共享相同的PID命名空间（但是该特征默认是未激活的）。</p>
<p>k8s集群的pod之间没有NAT网关，两个pod彼此之间发送网络数据包时，它们都会将对方的实际IP地址看作数据包中的源IP。</p>
<h3 id="3-1-3-通过-pod-合理管理容器-56"><a href="#3-1-3-通过-pod-合理管理容器-56" class="headerlink" title="3.1.3 通过 pod 合理管理容器 56"></a>3.1.3 通过 pod 合理管理容器 56</h3><p>当决定是将两个容器放入一个pod还是 两个单独的pod时，我们需要问自己以下问题:</p>
<ul>
<li>它们需要 一起运行还是可以在不同的主机上运行?</li>
<li>它们代表的是一个整体还是相互独立的组件?</li>
<li>它们必须一起进行扩缩容还是可以分别进行? </li>
</ul>
<p>我们总是应该倾向于在单独的pod中运行容器，除非有特定的原因要求它们是同一pod的一部分。<br>比如常见的是sidecar容器，用于日志轮转器和收集器、数据处理器、通信适配器等。</p>
<blockquote>
<p>在实际业务场景中，在pod中使用多个容器，sidecar是最常见的方式。其它情况，需要三思。</p>
</blockquote>
<img width="600" src="/images/Kubernetes In Action阅读笔记/8.png">

<h2 id="3-2-以-YAML-或-JSON-描述文件创建-pod-58"><a href="#3-2-以-YAML-或-JSON-描述文件创建-pod-58" class="headerlink" title="3.2 以 YAML 或 JSON 描述文件创建 pod 58"></a>3.2 以 YAML 或 JSON 描述文件创建 pod 58</h2><p>pod和其它k8s资源通常是通过向k8s REST API提供JSON或YAML描述文件来创建的。<br>全面的文档在<a href="https://kubernetes.io/docs/reference/kubernetes-api/" target="_blank" rel="noopener">Kubernetes API参考文档</a>。</p>
<h3 id="3-2-1-检查现有-pod-的-YAML-描述文件-59"><a href="#3-2-1-检查现有-pod-的-YAML-描述文件-59" class="headerlink" title="3.2.1 检查现有 pod 的 YAML 描述文件 59"></a>3.2.1 检查现有 pod 的 YAML 描述文件 59</h3><p>pod定义由这几个部分组成：首先是YAML中使用的k8s API版本和YAML描述的资源类型；其次是几乎在所有k8s资源中都可以找到的三大重要部分：</p>
<ul>
<li>metadata：包括名称、命名空间、标签和关于该容器的其他信息。</li>
<li>spec：包含pod内容的实际说明，例如pod的容器、卷和其他数据。</li>
<li>status：包含运行中的pod的当前信息，例如pod所处的条件、 每个容器的描述和状态，以及内部IP和其他基本信息。status只包含只读的运行时数据，在创建新的pod时，不需要提供status部分。</li>
</ul>
<h3 id="3-2-2-为-pod-创建一个简单的-YAML-描述文件-61"><a href="#3-2-2-为-pod-创建一个简单的-YAML-描述文件-61" class="headerlink" title="3.2.2 为 pod 创建一个简单的 YAML 描述文件 61"></a>3.2.2 为 pod 创建一个简单的 YAML 描述文件 61</h3><p>一个基本的pod描述文件非常简单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-manual</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - image: luksa&#x2F;kubia</span><br><span class="line">    name: kubia</span><br><span class="line">    ports:</span><br><span class="line">    - containerPort: 8080</span><br><span class="line">      protocol: TCP</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-使用-kubectl-create-来创建-pod-63"><a href="#3-2-3-使用-kubectl-create-来创建-pod-63" class="headerlink" title="3.2.3 使用 kubectl create 来创建 pod 63"></a>3.2.3 使用 kubectl create 来创建 pod 63</h3><p><code>kubectl create -f</code>命令用于从YAML或JSON文件创建任何资源。创建后可以请求k8s获得完整的YAML和JSON格式的描述文件。</p>
<h3 id="3-2-4-查看应用程序日志-64"><a href="#3-2-4-查看应用程序日志-64" class="headerlink" title="3.2.4 查看应用程序日志 64"></a>3.2.4 查看应用程序日志 64</h3><p>当日志文件达到一定大小时，容器日志会自动轮替。<code>kubectl logs</code>命令仅显示最后一次轮替后的日志条目。</p>
<p>当一个pod被删除时，它的日志也会被删除。如果希望在pod删除之后仍然可以获取其日志，我们需要设置中心化的、集群范围的日志系统，将所有日志存储到中心存储中。 </p>
<h3 id="3-2-5-向-pod-发送请求-65"><a href="#3-2-5-向-pod-发送请求-65" class="headerlink" title="3.2.5 向 pod 发送请求 65"></a>3.2.5 向 pod 发送请求 65</h3><p>如果要在外部访问pod，除了前面提到的lb service，还可以借助端口转发（常用于开发中测试pod）。端口转发通过<code>kubectl port-forward</code>命令完成。</p>
<img width="600" src="/images/Kubernetes In Action阅读笔记/9.png">

<h2 id="3-3-使用标签组织-pod-66"><a href="#3-3-使用标签组织-pod-66" class="headerlink" title="3.3 使用标签组织 pod 66"></a>3.3 使用标签组织 pod 66</h2><p>通过一次操作对属于某个组的所有pod进行操作，而不必单独为每个pod执行操作。<br>标签可以做到这一点。通过标签来组织pod和所有其他k8s对象。</p>
<h3 id="3-3-1-介绍标签-66"><a href="#3-3-1-介绍标签-66" class="headerlink" title="3.3.1 介绍标签 66"></a>3.3.1 介绍标签 66</h3><p>标签是可以附加到资源的任意键值对。通过标签选择器可以选择具有确切标签的资源。<br>标签和资源是多对多关系。</p>
<p>比如常用的场景有，给每个pod标有两个标签。</p>
<ul>
<li>app：它指定pod属于哪个应用、 组件或微服务。</li>
<li>rel：它显示在pod中运行的应用程序版本是stable、beta还是canary（用于金丝雀发布）。</li>
</ul>
<img width="600" src="/images/Kubernetes In Action阅读笔记/10.png">

<h3 id="3-3-2-创建-pod-时指定标签-67"><a href="#3-3-2-创建-pod-时指定标签-67" class="headerlink" title="3.3.2 创建 pod 时指定标签 67"></a>3.3.2 创建 pod 时指定标签 67</h3><p>包含creation_method=manual，env=prod两个标签。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-manual-v2</span><br><span class="line">  labels:</span><br><span class="line">    creation_method: manual</span><br><span class="line">    env: prod</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3-修改现有-pod-的标签-68"><a href="#3-3-3-修改现有-pod-的标签-68" class="headerlink" title="3.3.3 修改现有 pod 的标签 68"></a>3.3.3 修改现有 pod 的标签 68</h3><p>标签可以在现有pod上进行添加和修改。</p>
<h2 id="3-4-通过标签选择器列出-pod-子集-69"><a href="#3-4-通过标签选择器列出-pod-子集-69" class="headerlink" title="3.4 通过标签选择器列出 pod 子集 69"></a>3.4 通过标签选择器列出 pod 子集 69</h2><p>标签要与标签选择器结合，否则标签没有作用。</p>
<h3 id="3-4-1-使用标签选择器列出-pod-69"><a href="#3-4-1-使用标签选择器列出-pod-69" class="headerlink" title="3.4.1 使用标签选择器列出 pod 69"></a>3.4.1 使用标签选择器列出 pod 69</h3><p>标签选择器根据资源的以下条件来选择资源：</p>
<ul>
<li>包含(或不包含)使用特定键的标签。</li>
<li>包含具有特定键和值的标签。</li>
<li>包含具有特定键的标签，但其值与我们指定的不同。</li>
</ul>
<h3 id="3-4-2-在标签选择器中使用多个条件-71"><a href="#3-4-2-在标签选择器中使用多个条件-71" class="headerlink" title="3.4.2 在标签选择器中使用多个条件 71"></a>3.4.2 在标签选择器中使用多个条件 71</h3><p>在包含多个逗号分隔的清况下，可以在标签选择器中同时使用多个条件。 此时，资源需要全部匹配才算成功匹配了选择器。</p>
<h2 id="3-5-使用标签和选择器来约束-pod-调度-71"><a href="#3-5-使用标签和选择器来约束-pod-调度-71" class="headerlink" title="3.5 使用标签和选择器来约束 pod 调度 71"></a>3.5 使用标签和选择器来约束 pod 调度 71</h2><p>在硬件基础设施不是同质的情况下，比如想将执行GPU密集型运算的pod调度到提供GPU加速的节点上，需要约束pod的调度。这可以通过节点标签和节点标签选择器完成。</p>
<h3 id="3-5-1-使用标签分类工作节点-72"><a href="#3-5-1-使用标签分类工作节点-72" class="headerlink" title="3.5.1 使用标签分类工作节点 72"></a>3.5.1 使用标签分类工作节点 72</h3><p>pod并不是唯一可以附加标签的k8s资源。标签可以附加到任何k8s对象上，包括节点。 </p>
<h3 id="3-5-2-将-pod-调度到特定节点-72"><a href="#3-5-2-将-pod-调度到特定节点-72" class="headerlink" title="3.5.2 将 pod 调度到特定节点 72"></a>3.5.2 将 pod 调度到特定节点 72</h3><p>在spec部分添加了一个<code>nodeSelector</code>字段。当创建该pod时，调度器将只在包含标签gpu=true的节点中选择。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">spec:</span><br><span class="line">  nodeSelector:</span><br><span class="line">    gpu: &quot;true&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="3-5-3-调度到一个特定节点-73"><a href="#3-5-3-调度到一个特定节点-73" class="headerlink" title="3.5.3 调度到一个特定节点 73"></a>3.5.3 调度到一个特定节点 73</h3><p>也可以将pod调度到某个确定的节点，由于每个节点都有一个唯一标签，其中键为<code>kubernetes.io/hostname</code>， 值为该节点的实际主机名， 因此也可以将pod调度到某个确定的节点。但如果节点处于离线状态，通过hostname标签将nodeSelector设置为特定节点可能会导致pod不可调度。所以绝不应该考虑单个节点，而是应该通过标签选择器考虑符合特定标准的逻辑节点组。</p>
<h2 id="3-6-注解-pod-73"><a href="#3-6-注解-pod-73" class="headerlink" title="3.6 注解 pod 73"></a>3.6 注解 pod 73</h2><p>pod和其它对象还可以包含注解。注解也是键值对。但是注解不能像标签一样用于对对象分组。不存在注解选择器这样的东西。</p>
<h3 id="3-6-1-查找对象的注解-74"><a href="#3-6-1-查找对象的注解-74" class="headerlink" title="3.6.1 查找对象的注解 74"></a>3.6.1 查找对象的注解 74</h3><p>注解可以包含相对更多的数据，标签则是应该比较简短的。</p>
<h3 id="3-6-2-添加和修改注解-74"><a href="#3-6-2-添加和修改注解-74" class="headerlink" title="3.6.2 添加和修改注解 74"></a>3.6.2 添加和修改注解 74</h3><p>通过<code>kubectl annotate</code>命令添加和修改注解。</p>
<h2 id="3-7-使用命名空间对资源进行分组-75"><a href="#3-7-使用命名空间对资源进行分组-75" class="headerlink" title="3.7 使用命名空间对资源进行分组 75"></a>3.7 使用命名空间对资源进行分组 75</h2><p>k8s中可供声明的类称为资源（Resource），包括 pod、rs、deployment 等。声明一个资源构成的实例都有名字，这些名字都归属于一个个的命名空间之中（namespace），互不影响。</p>
<h3 id="3-7-1-了解对命名空间的需求-75"><a href="#3-7-1-了解对命名空间的需求-75" class="headerlink" title="3.7.1 了解对命名空间的需求 75"></a>3.7.1 了解对命名空间的需求 75</h3><p>在使用多个namespace的前提下，可以将包含大量组件的复杂系统拆分为更小的不同组，这些不同组也可以用于在多租户环境中分配资源，将资源分配为生产、开发和QA环境。两个不同命名空间可以包含同名资源。</p>
<blockquote>
<p>我们在业务上也这样使用过，为了减小硬件开销，开发和QA环境使用同一套k8s集群，使用不同的namespace区分。</p>
</blockquote>
<h3 id="3-7-2-发现其他命名空间及其-pod-75"><a href="#3-7-2-发现其他命名空间及其-pod-75" class="headerlink" title="3.7.2 发现其他命名空间及其 pod 75"></a>3.7.2 发现其他命名空间及其 pod 75</h3><p>命名空间除了为资源名称提供了一个作用域，也可用于仅允许某些用户访问某些特定资源，甚至限制单个用户可用的计算资源数量。</p>
<h3 id="3-7-3-创建一个命名空间-76"><a href="#3-7-3-创建一个命名空间-76" class="headerlink" title="3.7.3 创建一个命名空间 76"></a>3.7.3 创建一个命名空间 76</h3><p>k8s中的所有资源都是一个API对象。命名空间同理，所以创建namespace也可以用YAML文件描述，使用<code>kubectl create -f xxx.yaml</code>创建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">  name: custom-namespace</span><br></pre></td></tr></table></figure>

<p>也可以通过<code>kubectl create namespace</code>命令创建。</p>
<h3 id="3-7-4-管理其他命名空间中的对象-77"><a href="#3-7-4-管理其他命名空间中的对象-77" class="headerlink" title="3.7.4 管理其他命名空间中的对象 77"></a>3.7.4 管理其他命名空间中的对象 77</h3><p>在列出、描述、创建、修改、删除等操作中，需要给<code>kubectl</code>命令传递<code>--namespace</code>。否则<code>kubectl</code>在当前上下文中配置的默认命名空间执行操作。</p>
<p>当前上下文的命名空间可以通过<code>kubectl config</code>修改。要想快速切换到不同的命名空间，可以设置以下别名：<code>alias kcd=&#39;kubectl config set-context $(kubectl config current-context) --namespace&#39;</code>。然后使用<code>kcd some-namespace</code>在命名空间之间进行切换。</p>
<h3 id="3-7-5-命名空间提供的隔离-78"><a href="#3-7-5-命名空间提供的隔离-78" class="headerlink" title="3.7.5 命名空间提供的隔离 78"></a>3.7.5 命名空间提供的隔离 78</h3><p>你需要首先创建命名空间，然后再创建资源。</p>
<p>k8s 包含三个预设的命名空间：</p>
<ul>
<li>default</li>
<li>kube-public</li>
<li>kube-system</li>
</ul>
<p>命名空间之间是否网络隔离依赖于k8s使用的NetworkPolicy的配置。</p>
<h2 id="3-8-停止和移除-pod-78"><a href="#3-8-停止和移除-pod-78" class="headerlink" title="3.8 停止和移除 pod 78"></a>3.8 停止和移除 pod 78</h2><h3 id="3-8-1-按名称删除-pod-78"><a href="#3-8-1-按名称删除-pod-78" class="headerlink" title="3.8.1 按名称删除 pod 78"></a>3.8.1 按名称删除 pod 78</h3><p>在删除pod的过程中，实际上我们指示k8s终止该pod中的所有容器。k8s会向进程发送SIGTERM信号并等待一定时间，使其正常关闭（所以为了确保进程能正常关闭，业务代码中需要处理SIGTERM信号）。如果没有及时关闭，k8s则通过发送SIGKILL终止该进程。</p>
<h3 id="3-8-2-使用标签选择器删除-pod-79"><a href="#3-8-2-使用标签选择器删除-pod-79" class="headerlink" title="3.8.2 使用标签选择器删除 pod 79"></a>3.8.2 使用标签选择器删除 pod 79</h3><p>可以使用标签一次删除所有指定标签的pod。</p>
<h3 id="3-8-3-通过删除整个命名空间来删除-pod-80"><a href="#3-8-3-通过删除整个命名空间来删除-pod-80" class="headerlink" title="3.8.3 通过删除整个命名空间来删除 pod 80"></a>3.8.3 通过删除整个命名空间来删除 pod 80</h3><p>删除整个命名空间，pod将也会自动删除。</p>
<h3 id="3-8-4-删除命名空间中的所有-pod，但保留命名空间-80"><a href="#3-8-4-删除命名空间中的所有-pod，但保留命名空间-80" class="headerlink" title="3.8.4 删除命名空间中的所有 pod，但保留命名空间 80"></a>3.8.4 删除命名空间中的所有 pod，但保留命名空间 80</h3><p>要删除pod，还需要删除ReplicationController，否则会根据YAML描述文件自动创建新的pod。因为k8s是声明式设计。</p>
<h3 id="3-8-5-删除命名空间中的（几乎）所有资源-80"><a href="#3-8-5-删除命名空间中的（几乎）所有资源-80" class="headerlink" title="3.8.5 删除命名空间中的（几乎）所有资源 80"></a>3.8.5 删除命名空间中的（几乎）所有资源 80</h3><p><code>--all</code>删除所有内容并不是真的删除所有内容，一些资源例如secret会被保留下来，除非明确指定删除。</p>
<h2 id="3-9-本章的k8s命令"><a href="#3-9-本章的k8s命令" class="headerlink" title="3.9 本章的k8s命令"></a>3.9 本章的k8s命令</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">########## 查看pod ########## </span><br><span class="line"></span><br><span class="line"># 查看已部署的pod的完整YAML</span><br><span class="line">$ kubectl get pod kubia-zxzij -o yaml</span><br><span class="line"></span><br><span class="line"># 查看API对象支持的属性和解释</span><br><span class="line">$ kubectl explain pods</span><br><span class="line">$ kubectl explain pods.spec</span><br><span class="line"></span><br><span class="line"># 得到运行中的pod的完整定义</span><br><span class="line">$ kubectl get pod kubia-manual -o yaml</span><br><span class="line">$ kubectl get pod kubia-manual -o json</span><br><span class="line"></span><br><span class="line">########## 创建资源 ##########  </span><br><span class="line"></span><br><span class="line"># 从文件(YAML或JSON)创建资源</span><br><span class="line">$ kubectl create -f kubia-manual.yaml</span><br><span class="line"></span><br><span class="line">########## 查看日志 ##########  </span><br><span class="line"></span><br><span class="line"># 查看pod日志(准确地说是容器的日志)</span><br><span class="line">$ kubectl logs kubia-manual -c kubia</span><br><span class="line"></span><br><span class="line">########## 端口转发 ##########  </span><br><span class="line"></span><br><span class="line"># 将本地端口8888转发到pod端口8080</span><br><span class="line">$ kubectl port-forward kubia-manual 8888:8080</span><br><span class="line"></span><br><span class="line">########## label ##########  </span><br><span class="line"></span><br><span class="line"># 列出pod，带上标签</span><br><span class="line">$ kubectl get pod --show-labels</span><br><span class="line"></span><br><span class="line"># 列出pod，仅展示指定标签</span><br><span class="line">$ kubectl get pod -L creation_method,env</span><br><span class="line"></span><br><span class="line"># 为pod添加标签</span><br><span class="line">$ kubectl label pod kubia-manual creation_method&#x3D;manual</span><br><span class="line"></span><br><span class="line"># 为pod修改标签</span><br><span class="line">$ kubectl label pod kubia-manual-v2 env&#x3D;debug --overwrite</span><br><span class="line"></span><br><span class="line"># 列出包含creation_method标签，值等于manual的pod</span><br><span class="line">$ kubectl get pod -l creation_method&#x3D;manual</span><br><span class="line"></span><br><span class="line"># 列出包含env标签的pod</span><br><span class="line">$ kubectl get pod -l env</span><br><span class="line"></span><br><span class="line"># 列出没有env标签的pod</span><br><span class="line">$ kubectl get pod -l &#39;!env&#39;</span><br><span class="line"></span><br><span class="line"># 其它标签筛选条件</span><br><span class="line">creation_method!&#x3D;manual：选择带有creation_method标签，并且值不等于manual的pod。</span><br><span class="line">env in (prod, devel)：选择带有env标签且值为prod或devel的pod。</span><br><span class="line">env notin (prod, devel)：选择带有env标签，但其值不是prod或devel的pod。</span><br><span class="line"></span><br><span class="line"># 给节点添加标签gpu&#x3D;true</span><br><span class="line">$ kubectl label node gke-kubia-85f6-node-orrx gpu&#x3D;true</span><br><span class="line"></span><br><span class="line"># 列出只包含标签gpu&#x3D;true的节点</span><br><span class="line">$ kubectl get nodes -l gpu&#x3D;true</span><br><span class="line"></span><br><span class="line"># 列出所有节点，展示gpu标签值附加列</span><br><span class="line">$ kubectl get nodes -L gpu</span><br><span class="line"></span><br><span class="line">########## annotations ##########  </span><br><span class="line"></span><br><span class="line"># 给pod添加注解，将注解mycompany.com&#x2F;someannotation添加为值foo bar</span><br><span class="line">$ kubectl annotate pod kubia-manual mycompany.com&#x2F;someannotation&#x3D;&quot;foo bar&quot;</span><br><span class="line"></span><br><span class="line"># 查看pod的注解</span><br><span class="line">$ kubectl describe pod kubia-manual | grep annotations</span><br><span class="line"></span><br><span class="line">########## namespace ##########</span><br><span class="line"></span><br><span class="line"># 列出所有命名空间</span><br><span class="line">$ kubectl get ns</span><br><span class="line"></span><br><span class="line"># 列出属于命名空间kube-system的pod</span><br><span class="line">$ kubectl get pod --namespace kube-system（--namespace的缩写是-n）</span><br><span class="line"></span><br><span class="line"># 创建命名空间</span><br><span class="line">$ kubectl create namespace custom-namespace</span><br><span class="line"></span><br><span class="line">########## 删除资源 ##########</span><br><span class="line"></span><br><span class="line"># 删除pod</span><br><span class="line">$ kubectl delete pod kubia-gpu</span><br><span class="line"></span><br><span class="line"># 删除指定标签的pod</span><br><span class="line">$ kubectl delete pod -l create_method&#x3D;manual</span><br><span class="line"></span><br><span class="line"># 删除指定命名空间</span><br><span class="line">$ kubectl delete ns custom-namespace</span><br><span class="line"></span><br><span class="line"># 删除当前命名空间中的所有pod</span><br><span class="line">$ kubectl delete pod --all</span><br><span class="line"></span><br><span class="line"># 删除当前命名空间的所有资源(并不是真的删除所有内容)</span><br><span class="line">$ kubectl delete all --all</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pearlzju.github.io/2021/06/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%20IO%E6%A8%A1%E5%9E%8B(%E4%B8%80)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Pearl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/face.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pearl 的个人小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%20IO%E6%A8%A1%E5%9E%8B(%E4%B8%80)/" itemprop="url">深入理解Linux IO模型(一)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-12T10:43:55+08:00">
                2021-06-12
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/06/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%20IO%E6%A8%A1%E5%9E%8B(%E4%B8%80)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/06/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%20IO%E6%A8%A1%E5%9E%8B(%E4%B8%80)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2021/06/12/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%20IO%E6%A8%A1%E5%9E%8B(%E4%B8%80)/" class="leancloud_visitors" data-flag-title="深入理解Linux IO模型(一)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<p>Linux IO模型是后端工程师的必备技能。从以往的面试中看，部分后端开发人员对它的理解停留在调API的层面，我自己也理解欠缺。最近系统学习了一下，整理了此文。本文参考了一些文章，放在本文最后，大家可以直接去看这些文章，值得阅读。</p>
<blockquote>
<ol>
<li>本文为了描述方便，统一用读操作讲述，写操作同理。</li>
<li>本文为了撰写方便，统一将I/O写成了IO。</li>
<li>欢迎指正文中的错误。</li>
</ol>
</blockquote>
<h3 id="操作系统预备知识"><a href="#操作系统预备知识" class="headerlink" title="操作系统预备知识"></a>操作系统预备知识</h3><h4 id="UNIX体系结构"><a href="#UNIX体系结构" class="headerlink" title="UNIX体系结构"></a>UNIX体系结构</h4><p>UNIX操作系统的体系结构如图所示。</p>
<img width="250" src="/images/深入理解Linux IO模型/1.png">

<p>内核(kernel)：控制计算机硬件资源，提供程序运行环境。<br>系统调用(system call)：内核的函数接口。<br>公共函数库：构建在系统调用之上的函数接口。<br>shell：特殊的应用程序，为运行其他应用程序提供了一个接口。<br>应用程序：用户编写的程序。可使用公共函数库，也可直接调用系统调用。</p>
<h4 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h4><p>进一步介绍下系统调用(syscall)。<br>内核用于控制硬件资源，例如从磁盘上读写文件，需要控制硬盘这个硬件设备做IO操作。应用代码通过调用内核暴露出来的系统调用接口来使内核进行IO操作。<br>如图所示，库函数调用系统调用接口，应用程序可以调用系统调用和库函数。</p>
<img width="250" src="/images/深入理解Linux IO模型/2.png">

<p>例如用户常用的<code>printf</code>函数，可以调用它输出内容到显示器上，但是控制显示器的输出是内核。系统调用提供的是<code>write</code>函数，<code>printf</code>是库函数，它封装了<code>write</code> 这个系统调用接口。</p>
<h4 id="用户空间和内核空间"><a href="#用户空间和内核空间" class="headerlink" title="用户空间和内核空间"></a>用户空间和内核空间</h4><p>对于32位CPU（表示CPU的寄存器长度为32位），指令集长度32位，数据总线宽度32位，地址总线宽度32位（因为受到寄存器长度的限制，再大也是浪费，无法把指令或数据从内存装载到寄存器或把寄存器的值写入内存）。因为地址总线宽度32位，所以最大寻址范围2^32，即对应 2^32*8bit=4GB 内存寻址空间。虽然内存的最大寻址容量只有4GB，但是每个进程的虚拟存储空间却都为4GB。</p>
<blockquote>
<p>虚拟存储空间是什么？</p>
<ol>
<li>MMU(内存管理单元)通过段页式存储管理，负责物理地址和逻辑地址(虚拟地址)的转化。逻辑空间可以理解为内存空间和磁盘空间之间的抽象，为了解决容量问题。</li>
<li>程序的局部性原理。CPU访问内存时，无论是存取指令还是数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。程序运行时，无需全部装入内存，如果访问页不在内存，发出缺页中断，发起页面置换（页面置换有常用的几种算法，FIFO、LFU、LRU）。</li>
</ol>
</blockquote>
<blockquote>
<p>操作系统怎么划分的虚拟存储空间？</p>
<ol>
<li>程序在磁盘中，加载进内存后，才能变成进程运行起来。内存的第一个进程是kernel。</li>
<li>kernel会注册一个GDT(Global Descriptor Table)，把4GB虚拟内存划分成用户空间和内核空间。最高的1GB，从虚拟地址 0xC0000000 到 0xFFFFFFFF），供内核使用，作为内核空间；较低的3GB，从虚拟地址0x00000000到0xBFFFFFFF），供各个应用进程使用，作为用户空间。</li>
</ol>
</blockquote>
<p>内核独立于普通的应用程序，可以访问受保护的内存空间，也有访问底层硬件设备的所有权限。为了保证内核的安全，用户进程不能直接操作内核。操作系统将4GB的虚拟存储空间划分为两部分，用户空间和内核空间。</p>
<blockquote>
<p>CPU如何区分指令来自内核空间还是用户空间的？<br>指令存储在内存中，通过数据总线加载到CPU的指令寄存器，CPU解码执行。实际上CPU本身并不能区分是谁发出的指令，而是通过特权等级来区分。以X86架构来说，CPU指令集的特权等级分为Ring0~3，内核空间对应指令集Ring0，具有最高权限，可以访问所有资源；用户空间对应指令集Ring3，不能直接访问硬件设备。</p>
</blockquote>
<blockquote>
<p>如果用户空间存在特权指令，CPU如何区分这个指令来自用户进程从而禁止执行？<br>CPU有两种执行模式，用户模式和内核模式。用户模式受到限制，某些指令不能被执行，某些寄存器不能被访问，IO设备也不能被访问。内核模式则没有这些限制，可以执行所有的机器指令，可以读写所有的内存位置。<br>这个问题我理解可能不到位，抛砖引玉。</p>
</blockquote>
<h4 id="用户态和内核态"><a href="#用户态和内核态" class="headerlink" title="用户态和内核态"></a>用户态和内核态</h4><p>进程运行时会有用户态和内核态的区别。<br>如图所示，程序执行时，如果执行的是用户空间的应用代码，这些代码运行在用户态；当调用了系统调用后，内核空间的内核代码就会执行，内核中的这些代码运行在内核态。</p>
<img width="250" src="/images/深入理解Linux IO模型/3.png">

<h4 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h4><p>进程有五个状态，创建、就绪、执行、阻塞和终止。<br>就绪状态：当进程被分配到除CPU以外所有必要的资源（包括PCB、栈空间、堆空间等）后。只要获得CPU的使用权，就可以立即执行。<br>执行状态：进程获得CPU，在执行的状态。单CPU同一时刻只能有一个进程在执行状态。<br>阻塞状态：因为某种原因如IO未就绪，进程放弃CPU的使用权，进入阻塞状态。</p>
<p>进程模型之间的切换关系如图所示。</p>
<img width="500" src="/images/深入理解Linux IO模型/4.png">

<p>进程切换(进程调度)是指操作系统通过某种进程调度算法决定哪个就绪进程可以获得CPU的使用权。进一步说，内核以一定策略挂起当前正在利用CPU运行的进程，并保存进程的上下文运行信息，然后分配CPU给某个就绪状态的另一个进程执行。</p>
<p>可以看出，进程阻塞是进程的主动行为，只有处于获得CPU在执行状态的进程，才可能转变成阻塞状态。当进程进入阻塞状态，不占用CPU资源。所以，在执行IO请求后进入阻塞状态的进程，是不占用CPU资源的。</p>
<blockquote>
<p>PCB(进程控制块)指的是什么？<br>PCB是进程常驻在内存中的通用数据结构，记录进程运行的全部信息，被用于操作系统调用时读取。记录包括进程的标识符、状态、优先级、程序计数器、内存指针、CPU的上下文数据、被进程占用的IO的状态信息、记账信息等。</p>
</blockquote>
<h4 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h4><p>理解中断，对理解IO模型很重要。</p>
<h5 id="任务事件"><a href="#任务事件" class="headerlink" title="任务事件"></a>任务事件</h5><p>操作系统是事件驱动的，只有在有中断、陷阱或系统调用时才执行。如图所示。</p>
<img width="500" src="/images/深入理解Linux IO模型/9.png">

<blockquote>
<p>为什么操作系统要采用事件驱动设计呢？</p>
<ol>
<li>操作系统不能信任用户进程</li>
</ol>
<ul>
<li>用户进程可能是错误的或恶意的</li>
<li>用户进程崩溃不应影响操作系统</li>
</ul>
<ol start="2">
<li>操作系统需要保证对所有用户进程公平性</li>
</ol>
<ul>
<li>一个进程不能霸占CPU时间</li>
<li>采用定时中断的方式</li>
</ul>
</blockquote>
<p>事件触发简化流程如图所示。</p>
<img width="400" src="/images/深入理解Linux IO模型/10.png">

<p>事件有中断和异常两类。中断由硬件或者程序触发，以引起操作系统的注意。异常由于非法操作而导致的。本文不讲异常，只讲中断。<br>中断又有硬件中断和软件中断之分：硬件中断由外部硬件设备触发；软件中断由应用进程触发。</p>
<p>每个中断都有一个编号，称为中断向量(interrupt vector)，用于在中断描述符表IDT(也称为中断向量表)中进行索引，从而获得中断服务程序的指针，即中断处理程序的入口点。</p>
<blockquote>
<p>为什么「中断向量」不叫「中断指针」？我猜可能是历史原因，知道的读者可以留言告诉我。</p>
</blockquote>
<h5 id="硬件中断"><a href="#硬件中断" class="headerlink" title="硬件中断"></a>硬件中断</h5><p>与CPU相连接的外部设备，如键盘、鼠标、网卡等，偶尔需要CPU提供服务，但是CPU无法预测它们何时发生。<br>如果在数据采集系统中，可以采用CPU定期轮询设备的方式，以确定它们是否需要提供服务。否则，轮询会浪费CPU资源。<br>所以引入了硬件中断的方式，每个连接的外部设备都可以向CPU发出信号，表示它们需要CPU提供服务。一般来说，CPU有2个引脚，INT用于中断，NMI用于不可屏蔽的关键的信号。</p>
<p>如图所示，是8259可编程中断控制器。可支持转发8个中断。当设备通过中断请求(IRQ)引发中断，CPU确认并查询8259以确定哪个设备产生中断。8259可以为每个IRQ线分配优先权，可以级联以支持更多的中断。</p>
<img width="300" src="/images/深入理解Linux IO模型/11.png">

<p>当硬件中断发生的时候，发生了什么？流程如图所示。</p>
<img width="500" src="/images/深入理解Linux IO模型/12.png">

<img width="500" src="/images/深入理解Linux IO模型/13.png">

<p>第1步，CPU完成当前指令后，立即响应硬件中断，先获取到中断向量。<br>第2步，切换到内核堆栈不是必须的，因为只有从用户模式转到内核模式，才需要进行堆栈切换。有可能中断来临时，CPU正在内核模式执行内核的指令。<br>第3步，保存程序状态，是为了保证当前正常执行的程序在中断服务完成后能恢复。<br>第4步到第7步，是中断处理程序执行流程。</p>
<blockquote>
<p>典型的中断处理程序过程是:</p>
<ol>
<li>保存CPU上下文</li>
<li>处理中断(如与IO设备通信)</li>
<li>调用内核调度程序</li>
<li>恢复CPU上下文并返回</li>
</ol>
</blockquote>
<p>如图所示，中断处理是有延时的，最小值受限于中断控制器，它的最大值受到操作系统的限制，如当内核和中断处理程序需要操作同一个全局变量，需要保证内核执行的是原子操作，中断处理程序需要等待原子操作完成，才能得到处理。</p>
<img width="500" src="/images/深入理解Linux IO模型/14.png">

<h5 id="软件中断"><a href="#软件中断" class="headerlink" title="软件中断"></a>软件中断</h5><p>下面讲软件中断，它是为何产生？<br>为了让CPU能尽快响应其它硬件中断，中断处理程序需要小型化，可以只是设置flag或放入工作队列，让非关键性的代码推迟执行。于是提出了Top and Bottom Half Technique。<br>Top half：做最小的工作并从中断处理程序中返回。如保存寄存器、取消对其他中断的屏蔽、恢复寄存器并返回到以前的上下文。<br>Bottom half ：对Top half剩下的工作延迟处理。</p>
<p>硬件中断和软件中断的直观对比如图所示。硬件中断由一个设备（如PIC）向CPU的一个引脚发出信号产生；软件中断由正在执行的某条指令产生。</p>
<img width="400" src="/images/深入理解Linux IO模型/15.png">

<p>软件中断通过请求系统调用产生，如图所示。</p>
<img width="200" src="/images/深入理解Linux IO模型/16.png">

<p>一个write system call的例子，如图所示。</p>
<img width="250" src="/images/深入理解Linux IO模型/17.png">

<p>软件中断产生、处理和返回的流程，如图所示。</p>
<img width="500" src="/images/深入理解Linux IO模型/18.png">

<p>操作系统是如何区分系统调用的？答案是利用 System call number。直观上看，如图所示。</p>
<img width="400" src="/images/深入理解Linux IO模型/19.png">

<h3 id="数据包的接收过程"><a href="#数据包的接收过程" class="headerlink" title="数据包的接收过程"></a>数据包的接收过程</h3><h4 id="网卡-gt-内存"><a href="#网卡-gt-内存" class="headerlink" title="网卡-&gt;内存"></a>网卡-&gt;内存</h4><p>数据包如何进入内存，并被内核的网络模块开始处理的？流程如图所示。</p>
<img width="400" src="/images/深入理解Linux IO模型/20.png">

<ol>
<li>数据包进入网卡（如果目的地址不是该网卡，且该网卡没有开启混杂模式，该包会被网卡丢弃）。</li>
<li>网卡将数据包通过DMA方式写入指定的内存地址（该地址由网卡驱动分配并初始化）。</li>
<li>网卡raise硬件中断IRQ，通知CPU，告诉有数据包到来。</li>
<li>CPU查询中断向量表，得到中断服务程序的指针，这个中断服务程序会调用网卡驱动程序中的相应函数。</li>
<li>网卡驱动先禁用网卡的硬件中断，表示驱动程序已经知道内存中有网络数据，如果网卡下次再接收到数据包，直接DMA方式写内存就可以，不需要raise硬件中断通知CPU（这样避免CPU不停地被中断）。</li>
<li>网卡驱动程序raise软件中断，内核启动软件中断服务。目的是将硬件中断服务程序中耗时久的部分放到软中断函数慢慢处理。</li>
</ol>
<h4 id="内存-gt-内核网络模块-gt-内核网络协议栈"><a href="#内存-gt-内核网络模块-gt-内核网络协议栈" class="headerlink" title="内存-&gt;内核网络模块-&gt;内核网络协议栈"></a>内存-&gt;内核网络模块-&gt;内核网络协议栈</h4><p>内核在软件中断服务中接收链路层帧，并逐层递交上层协议栈处理，处理流程如下。</p>
<ol>
<li>内核中有专门的进程负责接收网卡驱动raise的软中断，然后该进程调用对应的软中断处理函数，读取之前网卡写到内存中的数据包。</li>
<li>网卡驱动程序知道如何处理内存中的数据包格式，它将数据包转换成内核网络模块能识别的格式。</li>
<li>内核网络模块将数据包合并(这样可以减小调用协议栈的次数)，并将数据包放入CPU对应的接收队列(softnet_data.input_pkt_queue)中等待处理。</li>
<li>CPU在软中断上下文中处理队列中的网络数据。</li>
<li>调用协议栈相应的函数，把数据包交给协议栈处理。</li>
<li>协议栈的处理过程（IP层-&gt;TCP/UDP层）不展开描述了。</li>
<li>用户空间的应用层通过调用socket接口接收数据。比如调用recvfrom函数阻塞等待数据到来，当socket fd收到通知后，recvfrom函数被唤醒，然后读取数据；或通过select/epoll等IO多路复用方式监听多个socket fd，只要其中有fd收到通知，进程主动调用recvfrom函数去读取数据。本文后面会展开描述。</li>
</ol>
<blockquote>
<p>CPU的接收队列input_pkt_queue是什么？<br>网络设备模块在初始化时，为每个CPU初始化结构体softnet_data，用于处理网络数据。input_pkt_queue是该结构体的一个成员变量，作为接收队列，在对其操作的时候，关闭当前CPU的中断。<br>如果接收队列input_pkt_queue不为空，将接收队列拼接到处理队列process_queue上。接收队列input_pkt_queue清空，继续处理添加到处理队列process_queue的数据包，并且在处理前就打开当前的CPU中断。</p>
</blockquote>
<h3 id="关于IO的认知"><a href="#关于IO的认知" class="headerlink" title="关于IO的认知"></a>关于IO的认知</h3><h4 id="IO是什么"><a href="#IO是什么" class="headerlink" title="IO是什么"></a>IO是什么</h4><p>IO是指Input/Output，即输入和输出。<br>IO从广义上说，是数据流动的过程。<br>IO有内存IO、网络IO和磁盘IO等。</p>
<p>从计算机架构上讲，CPU和内存与其他外部设备之间的数据转移过程就是IO。<br>本文从用户进程的角度理解IO。用户进程要完成IO读写，需要对内核发起IO调用，内核执行IO任务，返回IO结果，即完成一次IO。内核为每个IO设备维护一个内核缓冲区。</p>
<h4 id="不带缓冲的IO和带缓冲的IO"><a href="#不带缓冲的IO和带缓冲的IO" class="headerlink" title="不带缓冲的IO和带缓冲的IO"></a>不带缓冲的IO和带缓冲的IO</h4><p>IO分为不带缓冲的IO和带缓冲的IO（标准IO）。</p>
<p>不带缓冲的IO：读和写都调用内核中的系统调用read和write，写入内核缓冲区。</p>
<p>带缓冲的IO：目的是减少调用系统调用read和write的次数。方法是在用户空间建立流缓冲区。例如用户多次调用fwrite将数据写入流缓冲区，等流缓冲区满的时候只调用一次系统调用write，写入内核缓冲区。标准IO库实现的就是对IO流的缓存管理。</p>
<p>需要注意，不管是哪种IO，内存和磁盘之间，总是会有内核缓冲区的，这是IO设备的缓冲区。</p>
<p>总结一下数据流向路径:<br>不带缓冲的IO: 数据—内核缓存区—磁盘<br>带缓冲的IO: 数据—流缓存区—内核缓存区—磁盘</p>
<p>不管是哪种IO，因为用户进程是运行在用户空间的，不能直接操作内核缓冲区的数据。所以数据在传输过程中，总是需要从内核缓冲区复制到用户进程空间（对于带缓冲的IO，就是需要在内核缓冲区到用户缓冲区之间复制）。这个复制的过程对CPU和内存的开销是比较大的。</p>
<h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>文件描述符(fd)在形式上是一个非负整数。<br>内核用以标记一个特定进程正在访问的文件。<br>当内核打开一个现有的文件或创建一个新的文件时，内核返回一个文件描述符，用于后续的IO操作。</p>
<h4 id="流"><a href="#流" class="headerlink" title="流"></a>流</h4><p>流是可以进行读写操作的内核对象。<br>比如文件、管道、套接字。<br>Linux一切皆文件，一切都是流。用户进程都是对这些流进行读写操作，实现数据交换。<br>用户进程用文件描述符fd实现对流的操作。<br>准确地说，流是带缓冲的IO（标准IO）才有的概念。<br>流有方向。对流的读写操作，可以理解为IO操作。如图所示。</p>
<img width="250" src="/images/深入理解Linux IO模型/6.png">

<p>如果流中没有数据，读取，就阻塞。进一步说，是用户缓冲区没有数据，无法读取数据。</p>
<img width="250" src="/images/深入理解Linux IO模型/7.png">

<p>如果流中数据已满，写入，就阻塞。进一步说，是用户缓冲区数据已满，无法写入数据。</p>
<img width="250" src="/images/深入理解Linux IO模型/8.png">

<h4 id="IO操作"><a href="#IO操作" class="headerlink" title="IO操作"></a>IO操作</h4><p>对于用户进程的一个读IO操作，包括以下阶段：<br>1.用户进程调用IO系统调用读数据。<br>2.内核先看下内核缓冲区是否有数据，如果没有数据，则从设备读取，先加载到内核缓冲区，再复制到用户进程缓冲区；如果有数据，直接复制到用户进程缓冲区（对于标准IO）。</p>
<p>直观的流程如图所示。</p>
<img width="500" src="/images/深入理解Linux IO模型/5.png">

<p>具体地说，对于一个网络IO输入操作，如果内核缓冲区无数据，包括以下阶段：</p>
<ol>
<li>用户进程调用Socket API</li>
<li>等待网络数据到达网卡这个硬件设备</li>
<li>通过DMA，直接从网卡读取到内核缓冲区</li>
<li>内核把内核缓冲区的数据复制到用户空间</li>
</ol>
<p>总结一下，一次完整的网络IO输入操作，是应用进程进行系统调用，内核从网卡读取数据写入内存，接着内核把数据从内存中复制到到用户空间的过程。<br>这个过程，有很多种IO模型可以处理，就引发了下文要讲的同步IO（包括阻塞IO、非阻塞IO、IO多路复用）和异步IO模型。</p>
<h4 id="IO就绪"><a href="#IO就绪" class="headerlink" title="IO就绪"></a>IO就绪</h4><p>我们常说的fd就绪，也就是IO就绪，是IO可读或可写了，即应用程序调用的内核系统调用返回结果了，可以从内核缓冲区读取数据或者写入数据到内核缓冲区。</p>
<h3 id="同步IO和异步IO"><a href="#同步IO和异步IO" class="headerlink" title="同步IO和异步IO"></a>同步IO和异步IO</h3><p>IO模型从大类上分，分为同步IO和异步IO。</p>
<h4 id="同步IO-synchronous-IO"><a href="#同步IO-synchronous-IO" class="headerlink" title="同步IO(synchronous IO)"></a>同步IO(synchronous IO)</h4><p>应用程序通过系统调用发送IO请求给内核后，必须等待IO返回后才继续执行后续代码。<br>同步IO有以下几种模型。</p>
<h5 id="阻塞式IO-blocking-IO"><a href="#阻塞式IO-blocking-IO" class="headerlink" title="阻塞式IO(blocking IO)"></a>阻塞式IO(blocking IO)</h5><img width="400" src="/images/深入理解Linux IO模型/21.png">

<ol>
<li>应用进程调用系统调用recvfrom，应用进程进入阻塞状态。</li>
<li>内核准备好数据，写入内核缓冲区。</li>
<li>内核将数据从内核缓冲区复制到用户空间。</li>
<li>应用进程被唤醒，进入执行状态，处理拿到的数据。</li>
</ol>
<blockquote>
<p>R1和R2阶段的应用进程都是阻塞的。</p>
</blockquote>
<h5 id="非阻塞式IO-nonblocking-IO"><a href="#非阻塞式IO-nonblocking-IO" class="headerlink" title="非阻塞式IO(nonblocking IO)"></a>非阻塞式IO(nonblocking IO)</h5><img width="400" src="/images/深入理解Linux IO模型/22.png">

<ol>
<li>应用进程轮询调用系统调用recvfrom（非阻塞方式），如果内核未准备好数据，返回错误EWOULDBLOCK。</li>
<li>内核准备好数据，写入内核缓冲区。</li>
<li>这次应用进程调用系统调用recvfrom，内核会返回非错误码数据，并将数据从内核缓冲区复制到用户空间。</li>
<li>应用进程被唤醒，进入执行状态，处理拿到的数据。</li>
</ol>
<blockquote>
<p>R1阶段的应用进程是非阻塞的，R2阶段的应用进程是阻塞的。</p>
</blockquote>
<h5 id="IO多路复用-IO-multiplexing"><a href="#IO多路复用-IO-multiplexing" class="headerlink" title="IO多路复用(IO multiplexing)"></a>IO多路复用(IO multiplexing)</h5><img width="400" src="/images/深入理解Linux IO模型/23.png">

<ol>
<li>应用进程调用系统调用select（这里以select为例，还有poll、epoll等IO多路复用器），进程进入阻塞状态。（这里的阻塞不同于阻塞式IO只等待一个socket fd，而是同时等待多个socket fd）</li>
<li>内核将可读的socket fd数据准备好，写入内核缓冲区。</li>
<li>应用进程收到select的返回结果，知道存在任意数量可读的socket fd。对于这些socket fd，应用进程遍历socket fd（select和poll是遍历所有fd，epoll是只遍历可读的fd），分别调用系统调用recvfrom，内核将数据从内核缓冲区复制到用户空间。</li>
<li>应用进程被唤醒，进入执行状态，处理拿到的数据（多个socket fd的返回结果）。</li>
</ol>
<blockquote>
<p>R1和R2阶段的应用进程都是阻塞的。</p>
</blockquote>
<h5 id="信号驱动IO-signal-driven-IO"><a href="#信号驱动IO-signal-driven-IO" class="headerlink" title="信号驱动IO(signal-driven IO)"></a>信号驱动IO(signal-driven IO)</h5><img width="400" src="/images/深入理解Linux IO模型/24.png">

<ol start="0">
<li>应用进程内建立信号捕获函数，和socket fd关联。</li>
<li>应用进程调用系统调用sigaction，收到调用返回后，接着应用进程去执行其它代码。</li>
<li>当内核准备好数据，发送SIGIO信号给应用进程。</li>
<li>应用进程回调信号捕获函数，调用系统调用recvfrom。</li>
<li>应用进程被唤醒，进入执行状态，处理拿到的数据。</li>
</ol>
<blockquote>
<p>R1阶段的应用进程是非阻塞的，R2阶段的应用进程是阻塞的。</p>
</blockquote>
<h4 id="异步IO-asynchronous-IO"><a href="#异步IO-asynchronous-IO" class="headerlink" title="异步IO(asynchronous IO)"></a>异步IO(asynchronous IO)</h4><p>相对于同步IO，异步IO在用户进程调用系统调用aio_read以后，无论内核缓冲区数据是否准备好，都立即返回，不会阻塞当前进程，转而处理其它代码。</p>
<img width="400" src="/images/深入理解Linux IO模型/25.png">

<ol>
<li>应用进程调用系统调用aio_read，收到调用返回后，接着应用进程去执行其它代码。</li>
<li>内核准备好数据，并且将数据从内核缓冲区复制到用户空间。</li>
<li>内核发送aio_read中指定的信号给应用进程。</li>
<li>应用进程转而处理拿到的数据。</li>
</ol>
<blockquote>
<p>R1和R2阶段的应用进程都是非阻塞的。</p>
</blockquote>
<h3 id="为什么提出IO多路复用"><a href="#为什么提出IO多路复用" class="headerlink" title="为什么提出IO多路复用"></a>为什么提出IO多路复用</h3><p>以上在同步IO模型中已经介绍了IO多路复用。IO多路复用也是目前主流软件，如nginx、redis、kafka等使用的模型。它可以让一个线程在同一时刻监听多个socket fd。<br>技术的发展都是有迹可循，为了解决某种问题提出，那么IO多路复用是怎么产生的？</p>
<p>先介绍下阻塞等待和非阻塞忙轮询两种模型，分别对应上面同步IO中的阻塞式IO和非阻塞式IO。</p>
<h4 id="阻塞等待"><a href="#阻塞等待" class="headerlink" title="阻塞等待"></a>阻塞等待</h4><p>阻塞等待指的是被动地等待IO状态到来，即阻塞等待IO可读或可写。<br>阻塞等待的时候，CPU是空闲的，即不占用CPU的时间片（在上文已经说明原因）。<br>虽然不占用CPU时间片，但无法处理其它IO状态的到来（因为进程在阻塞状态等待IO可操作，无法进入就绪状态），即单个CPU无法并发处理多个IO请求。</p>
<p>优点：处理接收数据的时候，不浪费性能资源。<br>缺点：同一时刻，只能处理一个流的阻塞监听，即单个CPU不能并发处理多个IO请求。</p>
<p>虽然可以用阻塞+多线程/多进程的模型，实现多个CPU可以同一时刻监听多个IO状态。<br>但是开辟线程/进程浪费内存资源，而且切换线程/进程也浪费CPU。</p>
<h4 id="非阻塞忙轮询"><a href="#非阻塞忙轮询" class="headerlink" title="非阻塞忙轮询"></a>非阻塞忙轮询</h4><p>非阻塞忙轮询指的是主动地轮询IO状态，判断可读或可写。<br>非阻塞忙轮询判断IO状态的时候，CPU是忙碌的，即CPU时间片被占用。<br>注意：所以非阻塞忙轮询和异步是两个概念。</p>
<p>缺点：浪费CPU。</p>
<p>伪代码如下。CPU 大部分时间在做 while 和 for 判断处理，CPU 的利用率不高。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> i in 流[] &#123;</span><br><span class="line">    <span class="keyword">if</span> i has 数据 &#123;</span><br><span class="line">      读 或者 其他处理</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="IO多路复用解决的问题"><a href="#IO多路复用解决的问题" class="headerlink" title="IO多路复用解决的问题"></a>IO多路复用解决的问题</h4><p>最基础的网络编程伪代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">创建socketint s &#x3D; socket(AF_INET, SOCK_STREAM, 0); &#x2F;&#x2F; 得到socket fd</span><br><span class="line">绑定bind(s, ...)</span><br><span class="line">监听listen(s, ...)</span><br><span class="line">接受客户端连接int c &#x3D; accept(s, ...)</span><br><span class="line">接收客户端数据recv(c, ...);</span><br><span class="line">将数据打印出来printf(...)</span><br></pre></td></tr></table></figure>

<p>先创建socket fd，依次调用bind、listen、accept，最后调用recv接收数据。recv是个阻塞方法，当程序运行到recv时，进程进入阻塞状态（不占用CPU资源），直到接收到数据，进程转到执行状态处理数据。进程阻塞在accept和recv。</p>
<p>但是有没有一种方式，既有阻塞等待不浪费CPU资源的优点，也能避免阻塞等待同一时刻只能处理一个流的问题，而是可以在同一时刻监听多个socket fd？即同时accept和recv多个socket fd。答案就是IO多路复用。</p>
<p>所以产生了select、poll、epoll等IO多路复用技术，目的是解决单线程同一时刻处理大量IO读写请求，并且不浪费CPU。</p>
<h4 id="什么是-IO-多路复用"><a href="#什么是-IO-多路复用" class="headerlink" title="什么是 IO 多路复用"></a>什么是 IO 多路复用</h4><p>阻塞等待只能同一时刻只能监听一个IO状态。<br>为了解决大量 IO 请求读写的问题，提出了 IO 多路复用。<br>如果同一流程想同一时刻监听多个IO状态。要么非阻塞忙轮询；要么用 select/epoll等IO多路复用器，告诉用户态有哪些 IO 可读可写，一起处理。即 IO 多路复用可以实现单线程在同一时刻可以监听多个IO状态。IO多路复用在非忙轮询状态，不浪费CPU。</p>
<h4 id="select-简介"><a href="#select-简介" class="headerlink" title="select 简介"></a>select 简介</h4><p>先上伪代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">  select(流[]); <span class="comment">// 阻塞。CPU 可以去做其他事。如果有流可读了，返回。</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有消息抵达</span></span><br><span class="line">  <span class="keyword">for</span> i in 流 [] &#123; <span class="comment">// 需要依次判断所有的流哪个可读</span></span><br><span class="line">    <span class="keyword">if</span> i has 数据 &#123; <span class="comment">// 如果可读的流数量少，浪费性能</span></span><br><span class="line">        读 或者 其他处理</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>); </span><br><span class="line">bind(s, ...);</span><br><span class="line">listen(s, ...)</span><br><span class="line"><span class="keyword">int</span> fds[] = 存放需要监听的socket</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="keyword">int</span> n = select(..., fds, ...)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; fds.count; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(FD_ISSET(fds[i], ...))&#123;</span><br><span class="line">      <span class="comment">// fds[i]的数据处理</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>select的流程是：</p>
<ol>
<li>应用进程调用系统调用select(fds)。</li>
<li>select阻塞直到有任意数量fd可读。</li>
<li>应用进程遍历fds，通过FD_ISSET判断哪些socket fd可读。</li>
<li>应用进程处理返回的数据。</li>
</ol>
<p>select的缺点是：</p>
<ol>
<li>应用进程每次select系统调用都需要应用空间复制整个fds列表到内核空间。</li>
<li>内核需要主动遍历n次，才能返回哪些fd可读可写，CPU浪费在了内核空间。</li>
<li>规定select的最多同时监听1024个socket fd。</li>
<li>应用进程被唤醒后，不知道那些socket fd可读，需要遍历所有fd。</li>
</ol>
<h4 id="epoll-简介"><a href="#epoll-简介" class="headerlink" title="epoll 简介"></a>epoll 简介</h4><p>先上伪代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">true</span> &#123;</span><br><span class="line">  可处理的流[] = epoll_wait(epoll_fd); <span class="comment">// 阻塞</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 有消息抵达</span></span><br><span class="line">  <span class="keyword">for</span> i in 可处理的流[] &#123;</span><br><span class="line">    读 或者 其他处理</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进一步的代码。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">bind(s, ...);</span><br><span class="line">listen(s, ...)</span><br><span class="line"><span class="keyword">int</span> epfd = epoll_create(...);</span><br><span class="line">epoll_ctl(epfd, ...); <span class="comment">// 将所有需要监听的socket添加到epfd中</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">  <span class="keyword">int</span> n = epoll_wait(...)</span><br><span class="line">  <span class="keyword">for</span>(接收到数据的socket fds)&#123;</span><br><span class="line">    <span class="comment">// fds[i]的数据处理</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>epoll的流程是：</p>
<ol>
<li>应用进程调用系统调用epoll_create，创建eventpoll对象，用于维护等待列表和就绪列表。</li>
<li>应用进程调用系统调用epoll_ctl，添加要监听的fd。</li>
<li>应用进程调用系统调用epoll_wait。</li>
<li>epoll_wait阻塞直到有任意数量fd可读。</li>
<li>应用进程遍历就绪列表，得到数据。</li>
<li>应用进程处理返回的数据。</li>
</ol>
<p>epoll的优点是：</p>
<ol>
<li>可以同时监听大量的socket fd。能够处理大量的链接请求(系统可以打开的文件数目) 。</li>
<li>应用进程被唤醒后，只需要遍历可读的fd。</li>
</ol>
<blockquote>
<p><code>cat /proc/sys/fs/file-max</code> 得到当前操作系统可以打开的最大文件描述符个数。</p>
</blockquote>
<h3 id="epoll详解"><a href="#epoll详解" class="headerlink" title="epoll详解"></a>epoll详解</h3><p>关于epoll更多细节，在《深入理解Linux IO模型(二)》讲述。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>UNIX环境高级编程（第3版）<a href="https://book.douban.com/subject/25900403/" target="_blank" rel="noopener">https://book.douban.com/subject/25900403/</a><br><a href="http://www.cse.iitm.ac.in/~chester/courses/15o_os/slides/5_Interrupts.pdf" target="_blank" rel="noopener">http://www.cse.iitm.ac.in/~chester/courses/15o_os/slides/5_Interrupts.pdf</a><br><a href="https://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/" target="_blank" rel="noopener">https://blog.packagecloud.io/eng/2016/10/11/monitoring-tuning-linux-networking-stack-receiving-data-illustrated/</a><br><a href="https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/" target="_blank" rel="noopener">https://blog.packagecloud.io/eng/2016/06/22/monitoring-tuning-linux-networking-stack-receiving-data/</a><br><a href="https://mp.weixin.qq.com/s/kWDKpgmcOQFjoBAK3LyPTg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/kWDKpgmcOQFjoBAK3LyPTg</a><br><a href="https://juejin.cn/post/6892687008552976398#heading-26" target="_blank" rel="noopener">https://juejin.cn/post/6892687008552976398#heading-26</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pearlzju.github.io/2021/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%20IO%E6%A8%A1%E5%9E%8B(%E4%BA%8C)/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Pearl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/face.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pearl 的个人小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%20IO%E6%A8%A1%E5%9E%8B(%E4%BA%8C)/" itemprop="url">深入理解Linux IO模型(二)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-06-05T23:57:11+08:00">
                2021-06-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/" itemprop="url" rel="index">
                    <span itemprop="name">计算机</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%20IO%E6%A8%A1%E5%9E%8B(%E4%BA%8C)/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%20IO%E6%A8%A1%E5%9E%8B(%E4%BA%8C)/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2021/06/05/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%20IO%E6%A8%A1%E5%9E%8B(%E4%BA%8C)/" class="leancloud_visitors" data-flag-title="深入理解Linux IO模型(二)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>[TOC]</p>
<p>接着前文《深入理解Linux IO模型(一)》，本文深入分析IO多路复用模型中的epoll。</p>
<blockquote>
<ol>
<li>本文为了描述方便，统一用读操作讲述，写操作同理。</li>
<li>本文为了撰写方便，统一将I/O写成了IO。</li>
<li>欢迎指正文中的错误。</li>
</ol>
</blockquote>
<h3 id="为何使用epoll"><a href="#为何使用epoll" class="headerlink" title="为何使用epoll"></a>为何使用epoll</h3><p>Nginx在几十万并发连接下，是如何做到高效利用服务器资源的？答案是epoll。</p>
<p>设想一个场景：有100万用户同时与一个网络应用进程保持着TCP连接，而每一时刻只有几十或几百个TCP连接是活跃的（网络应用进程接收到TCP报文），那么在这个时刻，进程只需要处理这100万个连接中的这些活跃的连接即可。那么，内核和应用进程如何协同，才能高效地处理这种情况呢？</p>
<h4 id="select的缺陷"><a href="#select的缺陷" class="headerlink" title="select的缺陷"></a>select的缺陷</h4><p>应用进程是否在每次调用系统调用，询问内核有事件发生的TCP连接时，把这100万个连接告诉内核，由内核找出其中有事件发生的TCP连接呢？<br>这正是select的做法。</p>
<p>select有明显的缺陷，因为这100万个TCP连接中，大部分是没有事件发生的。如果应用程序每次收集事件时，都把这100万个socket fd传给内核。有以下问题：</p>
<ol>
<li>导致用户空间到内核空间的大量复制。</li>
<li>内核需要遍历所有的socket fd，判断哪些有事件到来。</li>
<li>应用进程仍需要遍历所有的socket fd，来判断哪些socket fd可读。</li>
</ol>
<p>所以select限制了同时监听的socket fd数量，最多只能同时处理1024个并发连接。</p>
<h4 id="epoll的提出"><a href="#epoll的提出" class="headerlink" title="epoll的提出"></a>epoll的提出</h4><p>epoll在内核中申请了一片内存空间。</p>
<p>epoll的做法是，把应用程序的一个select调用分成三部分：</p>
<ol>
<li>调用epoll_create创建一个epoll对象</li>
<li>调用epoll_ctl向epoll对象添加这100万个socket fd</li>
<li>调用epoll_wait等待收集发生事件的连接</li>
</ol>
<p>这样，只要在应用进程启动时，建立1个epoll对象(下文用epfd表示)，并在TCP连接到来和断开的时候，对epfd添加和删除事件就可以了（也可以修改）。<br>应用进程调用epoll_wait时，不需要向内核空间传递这100万个连接，内核也不需要遍历全部的连接。所以epoll_wait很高效。</p>
<h3 id="epoll的原理"><a href="#epoll的原理" class="headerlink" title="epoll的原理"></a>epoll的原理</h3><p>当应用进程调用epoll_create时，内核会在内核空间创建一个独立的eventpoll结构体对象，用于维护使用epoll_ctl向其添加的事件。</p>
<h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>epoll的数据结构如图所示。eventpoll有两个核心的数据结构：</p>
<ol>
<li>红黑树(rbr)：维护通过epoll_ctl添加的事件。</li>
<li>就绪链表(rdllist)：保存就绪的事件，当事件发生时，由内核的中断处理程序插入该就绪链表。</li>
</ol>
<img width="500" src="/images/深入理解Linux IO模型/29.png">

<blockquote>
<p>说明: 这张图来自于《深入理解Nginx》，网上很多博客用了这张图，但是这张图关于就绪链表的描述有个小错误。”红黑树中每个节点都是基于epitem结构中的rdllink成员”应该改成”就绪链表中每个节点都是基于epitem结构中的rdllink成员”。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里只列出了成员rbr、rdllist，它们和epoll的使用密切相关</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 红黑树的根节点，这棵树中存储着所有添加到epoll中的事件，即这个epoll监控的事件</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">rbr</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 双向链表rdllist保存着要通过epoll_wait返回给应用程序的满足条件的事件</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllist</span>;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epitem</span> &#123;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 红黑树节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rbn</span>;</span></span><br><span class="line">  <span class="comment">// 双向链表节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">rdllink</span>;</span></span><br><span class="line">  <span class="comment">// 事件句柄等信息</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_filefd</span> <span class="title">ffd</span>;</span></span><br><span class="line">  <span class="comment">// 指向其所属的eventpoll对象</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">eventpoll</span> *<span class="title">ep</span>;</span></span><br><span class="line">  <span class="comment">// 期待的事件类型</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>;</span></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>在epoll中，为每个事件都建立一个epitem结构体对象。<br>这些事件都会添加到rbr红黑树中（重复添加的事件可以通过红黑树高效地识别出来）。从红黑树中查找事件非常快。</p>
<p>所有添加到epoll对象中的事件都会与设备驱动程序（如网卡驱动程序）建立回调关系，当相应的事件发生时，会调用回调函数（中断处理程序）。这个回调函数在内核叫<code>ep_poll_callback</code>，回调函数会把就绪的事件写入rdllist双向链表中。</p>
<p>当应用程序调用epoll_wait检查是否有事件发生的连接时，内核只是检查eventpoll对象的rdllist双向链表是否有epitem元素而已。如果rdllist链表不为空，内核把这里的事件复制到用户空间，同时返回对应的事件数量。</p>
<h4 id="高效原因"><a href="#高效原因" class="headerlink" title="高效原因"></a>高效原因</h4><p>最后总结分析下epoll之所以可以处理百万级别的并发连接，而且效率很高的原因。</p>
<ol>
<li>应用程序在调用系统调用epoll_create创建epoll时，内核为它开辟了一片内存空间。把listen fd存在里面，以及当每次来客户端请求，三次握手后建立的client fd都会存在内核态的这个内存空间。这样不同于select，避免了用户空间和内核空间之间重复传递fd的过程。</li>
<li>应用程序要知道哪些事件可读了，不同于在select中应用程序需要主动遍历所有fd，内核只是将就绪列表中的事件复制到用户空间的event数组中（应用程序提前申请好的内存），这样应用程序只需要遍历这些就绪的事件。</li>
<li>就绪事件是怎么放入就绪列表的？答案是epoll利用了事件驱动。当数据包进入网卡，网卡将数据包通过DMA方式写入内存。网卡raise硬件中断IRQ，通知CPU有数据包到来了。CPU查询中断向量表，得到中断服务程序的指针，这个中断服务程序会调用网卡驱动程序。这里的中断服务程序是事先注册的，所以也可以理解CPU根据中断号回调中断处理程序，从内存读取数据，得到事件的fd，写入就绪列表rdllist中。</li>
</ol>
<blockquote>
<p>这里用到了上一篇《深入理解Linux IO模型(一)》写到的硬中断，不熟悉的可以看一下。</p>
</blockquote>
<p>从程序的本质上看，程序是否有更好的并发，是看少浪费了什么。<br>CPU、内存、硬盘、网络带宽的利用率决定程序是不是能应对更复杂的场景。<br>当遇到高并发问题，怀疑程序在服务器上运转不良好时，一定要回过头看硬件有没有被充分利用，有没有浪费硬件资源。<br>CPU在执行什么事情的指令，决定了它的利用率。<br>select需要CPU在内核模式下（CPU的一种执行模式）主动去遍历所有描述符，这样CPU浪费在了遍历上。而epoll靠的是硬件中断，利用中断把就绪fd写入就绪列表。更充分发挥了硬件，不浪费CPU。这是epoll高效的最大原因。</p>
<h3 id="epoll的API"><a href="#epoll的API" class="headerlink" title="epoll的API"></a>epoll的API</h3><p>epoll提供给应用程序的系统调用API有三个。</p>
<ul>
<li>创建epoll：epoll_create系统调用</li>
<li>控制epoll：epoll_ctl系统调用</li>
<li>等待epoll：epoll_wait系统调用</li>
</ul>
<h4 id="创建epoll"><a href="#创建epoll" class="headerlink" title="创建epoll"></a>创建epoll</h4><p>创建epoll，指的是在内核空间创建一颗红黑树（平衡二叉树）的根节点root。它返回一个fd（下文用epfd指代），用来标识这个epoll对象。这个root根节点与epfd相对应。如图所示。</p>
<img width="200" src="/images/深入理解Linux IO模型/26.png">

<p>API如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment"> * @param size 告诉epoll要处理的大致事件数量，而不是能处理的事件最大数量。</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * @returns 返回一个epoll句柄（即一个文件描述符） </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br></pre></td></tr></table></figure>

<p>调用方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> epfd = epoll_create(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>

<h4 id="控制epoll"><a href="#控制epoll" class="headerlink" title="控制epoll"></a>控制epoll</h4><p>控制epoll，指的是以下三种操作:</p>
<ul>
<li>注册新的事件到epoll</li>
<li>修改已经注册的事件</li>
<li>删除一个注册到epoll的事件</li>
</ul>
<p>添加某事件的时候，事件被插到红黑树的某个节点，并且与相应的设备驱动程序建立回调关系。当事件发生后，内核中断处理程序调用这个回调函数，将事件添加到就绪链表。</p>
<p>API如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @param epfd 用epoll_create所创建的epoll实例</span></span><br><span class="line"><span class="comment">* @param op 表示对epoll监控描述符控制的动作</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* EPOLL_CTL_ADD(添加新的事件到epoll中)</span></span><br><span class="line"><span class="comment">* EPOLL_CTL_MOD(修改已经注册到epoll中的事件)</span></span><br><span class="line"><span class="comment">* EPOLL_CTL_DEL(删除epoll中的事件)</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param fd 待监测的连接fd</span></span><br><span class="line"><span class="comment">* @param event 告诉内核需要监听的事件(包括类型)，指向epoll_event的指针</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @returns 成功返回0，失败返回-1, errno查看错误信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd,</span></span></span><br><span class="line"><span class="function"><span class="params">struct epoll_event *event)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events; <span class="comment">// epoll 事件</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data; <span class="comment">// 用户传递的数据</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">  <span class="keyword">void</span> *ptr;</span><br><span class="line">  <span class="keyword">int</span> fd; <span class="comment">// 监听的事件fd</span></span><br><span class="line">  <span class="keyword">uint32_t</span> u32;</span><br><span class="line">  <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>

<p>关于epoll_event，具体介绍下。上文介绍过epoll为每个事件创建epitem对象，在结构体epitem中有一个成员epoll_event。</p>
<p>epoll_event.events的取值包括：<br>EPOLLIN：表示对应的连接上有数据可以读出（TCP连接的远端主动关闭连接，也相当于可读事件，因为要处理发过来的FIN包）<br>EPOLLOUT：表示对应的连接上可以写入数据发送<br>EPOLLRDHUP：表示TCP连接的远端关闭或半关闭连接<br>EPOLLPR：表示对应的链接上有紧急数据需要读<br>EPOLLERR：表示对应的连接发生错误<br>EPOLLHUP：表示对应的连接被挂起<br>EPOLLET：表示将处罚方式设置为边缘触发（ET），系统默认为水平触发（LT）<br>EPOLLONESHOT：表示对这个事件只处理一次，下次需要处理时需要重新加入epoll</p>
<p>调用方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">new_event</span>;</span></span><br><span class="line"></span><br><span class="line">new_event.events = EPOLLIN | EPOLLOUT;</span><br><span class="line">new_event.data.fd = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, <span class="number">5</span>, &amp;new_event);</span><br></pre></td></tr></table></figure>

<p>在用户空间创建一个IO事件，绑定到某个fd上，然后把该事件的fd添加到内核中的epoll红黑树中。当fd可读或可写时，触发的是epoll_event。如图所示。</p>
<img width="500" src="/images/深入理解Linux IO模型/27.png">

<h4 id="等待epoll"><a href="#等待epoll" class="headerlink" title="等待epoll"></a>等待epoll</h4><p>收集在epoll监控的事件中已经发生的事件，内核会检查就绪链表中是否有存在添加过的事件，如果没有任何事件发生，最多等待timeout毫秒后返回（在timeout设置&gt;0的情况下）。返回值表示当前发生的事件个数。</p>
<p>API如下:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @param epfd 用epoll_create所创建的epoll实例</span></span><br><span class="line"><span class="comment">* @param event 从内核得到的就绪的事件集合</span></span><br><span class="line"><span class="comment">* @param maxevents 本次可以返回的最大事件数目，通常与预分配的event数组大小相等</span></span><br><span class="line"><span class="comment">* 注意: 值不能大于创建epoll_create()时的size</span></span><br><span class="line"><span class="comment">* @param timeout 等待IO事件发生的超时时间</span></span><br><span class="line"><span class="comment">* -1: 永久阻塞</span></span><br><span class="line"><span class="comment">* 0: 如果就绪链表rdllist为空，立即返回，不会等待，即非阻塞</span></span><br><span class="line"><span class="comment">* &gt;0: 指定最多等待的时间，单位毫秒</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* @returns 成功: 有多少文件描述符就绪,时间到时返回0</span></span><br><span class="line"><span class="comment">* 失败: -1, errno 查看错误</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *event,</span></span></span><br><span class="line"><span class="function"><span class="params">               <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意: epoll_event不能是空指针，内核只是负责把内核空间中就绪链表的数据复制到用户空间的event数组中，不会去帮忙分配内存，所以用户空间需要自己提前分配内存。</p>
</blockquote>
<p>调用方法:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">my_event</span>[1000];</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> event_cnt = epoll_wait(epfd, my_event, <span class="number">1000</span>, <span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>如图所示。应用程序调用epoll_wait后，进入阻塞状态。当内核检测到new_event或event1绑定的fd可读了，内核把就绪的event事件拷贝到用户空间的my_event数组。应用程序只需要遍历my_event，取出对应的事件和fd，知道是可读了，然后堵塞调用recv(fd)读数据。</p>
<img width="500" src="/images/深入理解Linux IO模型/28.png">

<h3 id="使用epoll-API"><a href="#使用epoll-API" class="headerlink" title="使用epoll API"></a>使用epoll API</h3><p>一个简单的使用epoll API的编程架构如下。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建epoll fd，最多可接收1000个事件</span></span><br><span class="line"><span class="keyword">int</span> epfd = epoll_crete(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将listen_fd添加进epoll中</span></span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, listen_fd, &amp;listen_event);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">  <span class="comment">// 阻塞等待epoll中的事件fd触发</span></span><br><span class="line">  <span class="keyword">int</span> active_cnt = epoll_wait(epfd, events, <span class="number">1000</span>, <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; active_cnt; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (evnets[i].data.fd == listen_fd) &#123;</span><br><span class="line">      <span class="comment">// 表示新的客户端连接请求到来</span></span><br><span class="line">      <span class="comment">// 调用accept进行三次握手，创建client_fd</span></span><br><span class="line">      <span class="comment">// 并将client_fd加进epoll中</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">      <span class="comment">// 表示不是新的客户端连接，可读客户端发来的数据</span></span><br><span class="line">      <span class="comment">// client_fd就绪可读，对此fd进行读操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">      <span class="comment">// 表示不是新的客户端连接，可把数据回写客户端</span></span><br><span class="line">      <span class="comment">// client_fd就绪可写，对此fd进行写操作</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如图所示，是一个服务器使用epoll的常规流程。</p>
<img width="1000" src="/images/深入理解Linux IO模型/30.png">

<h3 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h3><p>epoll有两种工作模式：水平触发和边缘触发。默认情况下，epoll采用水平触发模式。</p>
<h4 id="水平触发-Level-Triggered-LT"><a href="#水平触发-Level-Triggered-LT" class="headerlink" title="水平触发(Level Triggered, LT)"></a>水平触发(Level Triggered, LT)</h4><p>如果应用程序阻塞在epoll_wait，当内核有事件发生的时候，内核把已经触发的事件队列复制到用户空间。如果应用程序本次没有完成读操作，下一次epoll_wait会再次返回该事件。<br>即只要一个事件对应的套接字缓冲区还有数据，就总能从epoll_wait中获取这个事件。</p>
<p>优点：事件不会丢掉，除非应用程序处理完毕。保证事件的完整性。<br>缺点：如果应用程序不处理这个事件，就导致内核每次都把该事件从内核空间拷贝到用户空间，系统调用消耗性能。</p>
<h4 id="边缘触发-Edge-Triggered-ET"><a href="#边缘触发-Edge-Triggered-ET" class="headerlink" title="边缘触发(Edge Triggered, ET)"></a>边缘触发(Edge Triggered, ET)</h4><p>如果应用程序阻塞在epoll_wait，当内核有事件发生的时候，内核把已经触发的事件队列复制到用户空间。如果应用程序本次没有完成读操作，下一次epoll_wait不再会返回该事件。<br>即如果这次没有把这个事件对应的套接字缓冲区处理完，在这个套接字没有新的事件再次到来时，无法再次从epoll_wait调用中获取到这个事件。</p>
<p>优点：内核不会重复把该事件从内核空间拷贝到用户空间。保证性能。<br>缺点：如果应用程序没有处理完毕，事件会被丢掉。导致事件不完整。</p>
<h4 id="两者对比"><a href="#两者对比" class="headerlink" title="两者对比"></a>两者对比</h4><p>在水平触发模式下，开发基于epoll的应用要简单一些，不太容易出错。而在边缘触发模式下，当事件发生时，如果没有彻底地将缓冲区数据处理完，则会导致缓冲区中的用户请求得不到响应。</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>深入理解Nginx（第2版）<a href="https://book.douban.com/subject/26745255/" target="_blank" rel="noopener">https://book.douban.com/subject/26745255/</a><br><a href="https://mp.weixin.qq.com/s/kWDKpgmcOQFjoBAK3LyPTg" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/kWDKpgmcOQFjoBAK3LyPTg</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pearlzju.github.io/2021/05/26/%E8%AE%B0%E5%BD%95%E6%88%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E7%94%9F%E6%B4%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Pearl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/face.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pearl 的个人小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2021/05/26/%E8%AE%B0%E5%BD%95%E6%88%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E7%94%9F%E6%B4%BB/" itemprop="url">记录我的学习和生活</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2021-05-26T16:13:48+08:00">
                2021-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E4%B8%AA%E4%BA%BA/" itemprop="url" rel="index">
                    <span itemprop="name">个人</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2021/05/26/%E8%AE%B0%E5%BD%95%E6%88%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E7%94%9F%E6%B4%BB/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2021/05/26/%E8%AE%B0%E5%BD%95%E6%88%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E7%94%9F%E6%B4%BB/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2021/05/26/%E8%AE%B0%E5%BD%95%E6%88%91%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E7%94%9F%E6%B4%BB/" class="leancloud_visitors" data-flag-title="记录我的学习和生活">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>人唯有运用他所有的能力与才干，才能获得幸福。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://pearlzju.github.io/2019/10/21/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Pearl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/face.jpeg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Pearl 的个人小站">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/21/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-21T20:55:02+08:00">
                2019-10-21
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/10/21/hello-world/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/10/21/hello-world/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          
             <span id="/2019/10/21/hello-world/" class="leancloud_visitors" data-flag-title="Hello World">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/face.jpeg"
                alt="Pearl" />
            
              <p class="site-author-name" itemprop="name">Pearl</p>
              <p class="site-description motion-element" itemprop="description">爱自己是终身浪漫的开始</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Pearlzju" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:shanglin@zju.edu.cn" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/LINZJU" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i></a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.douban.com/people/104033946" target="_blank" title="豆瓣">
                      
                        <i class="fa fa-fw fa-globe"></i></a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Pearl</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: 'ECUWkqa8FVLG7NN721RUeTXk-gzGzoHsz',
        appKey: 'BEMbJ6wNDs62iTOP3UAxzVle',
        placeholder: '说点什么呢',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("ECUWkqa8FVLG7NN721RUeTXk-gzGzoHsz", "BEMbJ6wNDs62iTOP3UAxzVle");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
